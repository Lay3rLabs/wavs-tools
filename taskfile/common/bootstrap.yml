version: "3"

vars:
  # Common variable definitions
  SERVICE_JSON_CMD: 'service --json true --home /wavs-home --file "{{.WAVS_CLI_SERVICE_JSON_PATH}}"'

tasks:
  components-build:
    desc: "Builds the WASI components"
    deps: [components-clean]
    requires:
      vars:
        [
          PROJECT,
          COMPONENT_NAME,
          REPO_ROOT,
          ROOT_DIR,
          AGGREGATOR_PROJECT,
          AGGREGATOR_COMPONENT_NAME,
        ]
    vars:
      COMPONENT_SOURCE_DIR: '{{joinPath .ROOT_DIR "component"}}'
      AGGREGATOR_COMPONENT_SOURCE_DIR: '{{ joinPath .REPO_ROOT "projects" .AGGREGATOR_PROJECT "component" }}'
    cmds:
      - cd "{{.REPO_ROOT}}" && task component:build PROJECT="{{.PROJECT}}" COMPONENT_NAME="{{.COMPONENT_NAME}}" COMPONENT_SOURCE_DIR="{{.COMPONENT_SOURCE_DIR}}"
      - cd "{{.REPO_ROOT}}" && task component:build PROJECT="{{.PROJECT}}" COMPONENT_NAME="{{.AGGREGATOR_COMPONENT_NAME}}" COMPONENT_SOURCE_DIR="{{.AGGREGATOR_COMPONENT_SOURCE_DIR}}"

  components-clean:
    desc: "Deletes the WASI components"
    requires:
      vars: [PROJECT, COMPONENT_NAME, REPO_ROOT]
    cmds:
      - cd "{{.REPO_ROOT}}" && task component:clean-all PROJECT="{{.PROJECT}}" COMPONENT_NAME="{{.COMPONENT_NAME}}"

  components-upload:
    desc: "Uploads the WASI components"
    vars:
      WAVS_INSTANCE: "{{.WAVS_INSTANCE | default 1}}"
      WAVS_ENDPOINT:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-wavs-endpoint-{{.WAVS_INSTANCE}}
    requires:
      vars: [PROJECT, COMPONENT_NAME, REPO_ROOT, AGGREGATOR_COMPONENT_NAME]
    cmds:
      - cd "{{.REPO_ROOT}}" && task component:upload PROJECT="{{.PROJECT}}" COMPONENT_NAME="{{.COMPONENT_NAME}}" WAVS_ENDPOINT="{{.WAVS_ENDPOINT}}"
      - cd "{{.REPO_ROOT}}" && task component:upload-aggregator PROJECT="{{.PROJECT}}" COMPONENT_NAME="{{.AGGREGATOR_COMPONENT_NAME}}" WAVS_ENDPOINT="{{.WAVS_ENDPOINT}}"

  middleware-deploy:
    desc: "Deploys the middleware (mock, ecdsa, or poa based on MIDDLEWARE_MODE setting)"
    vars:
      MIDDLEWARE_MODE: '{{.MIDDLEWARE_MODE | default "EIGEN_ECDSA"}}'
      CHAIN_ARG: "{{if .SOURCE_CHAIN_NUMBER}}CHAIN_NUMBER={{.SOURCE_CHAIN_NUMBER}}{{end}}"
    requires:
      vars: [PROJECT, REPO_ROOT]
    cmds:
      - |
        case "{{.MIDDLEWARE_MODE}}" in
          "EIGEN_MOCK")
            cd "{{.REPO_ROOT}}" && task middleware:eigen:mock:deploy PROJECT="{{.PROJECT}}" SERVICE_NAME="{{.PROJECT}}" {{.CHAIN_ARG}}
            ;;
          "POA")
            cd "{{.REPO_ROOT}}" && task middleware:poa:deploy PROJECT="{{.PROJECT}}" SERVICE_NAME="{{.PROJECT}}" {{.CHAIN_ARG}}
            ;;
          *)
            cd "{{.REPO_ROOT}}" && task middleware:eigen:ecdsa:deploy PROJECT="{{.PROJECT}}" SERVICE_NAME="{{.PROJECT}}" {{.CHAIN_ARG}}
            ;;
        esac

  middleware-transfer-ownership:
    desc: "Transfer ownership of middleware contracts (conditional on TRANSFER_OWNERSHIP)"
    vars:
      TRANSFER_OWNERSHIP: '{{.TRANSFER_OWNERSHIP | default "false"}}'
      MIDDLEWARE_MODE: '{{.MIDDLEWARE_MODE | default "EIGEN_ECDSA"}}'
      CHAIN_ARG: "{{if .SOURCE_CHAIN_NUMBER}}CHAIN_NUMBER={{.SOURCE_CHAIN_NUMBER}}{{end}}"
    requires:
      vars: [PROJECT, REPO_ROOT, PROXY_OWNER, AVS_OWNER]
    status:
      - '[ "{{.TRANSFER_OWNERSHIP}}" != "true" ] || [ "{{.MIDDLEWARE_MODE}}" == "POA" ]'
    cmds:
      - |
        case "{{.MIDDLEWARE_MODE}}" in
          "EIGEN_MOCK")
            cd "{{.REPO_ROOT}}" && task middleware:mock:transfer-ownership PROJECT="{{.PROJECT}}" SERVICE_NAME="{{.PROJECT}}" PROXY_OWNER="{{.PROXY_OWNER}}" AVS_OWNER="{{.AVS_OWNER}}" {{.CHAIN_ARG}}
            ;;
          "POA")
            echo "POA middleware does not support ownership transfer - skipping"
            ;;
          *)
            cd "{{.REPO_ROOT}}" && task middleware:eigen:ecdsa:transfer-ownership PROJECT="{{.PROJECT}}" SERVICE_NAME="{{.PROJECT}}" PROXY_OWNER="{{.PROXY_OWNER}}" AVS_OWNER="{{.AVS_OWNER}}" {{.CHAIN_ARG}}
            ;;
        esac

  build-mock-config:
    desc: "Build mock configuration JSON with all active operators"
    vars:
      WEIGHT: "{{.WEIGHT | default 10000000}}"
      CHAIN_NUMBER: '{{.CHAIN_NUMBER | default "1"}}'
      NODES_DIR:
        sh: cd "{{.REPO_ROOT}}" && task middleware:get-output-dir CHAIN_NUMBER={{.CHAIN_NUMBER}} PROJECT={{.PROJECT}} SERVICE_NAME={{.PROJECT}}
      CONFIGURE_FILE: "wavs-mock-config.json"
    requires:
      vars: [PROJECT]
    cmds:
      - |
        # Build arrays for all active operators
        OPERATORS_JSON="[]"
        SIGNING_KEYS_JSON="[]"
        WEIGHTS_JSON="[]"

        for WAVS_INSTANCE in $(seq 1 {{.ACTIVE_WAVS_COUNT}}); do
          OPERATOR_MNEMONIC=$(cd "{{.REPO_ROOT}}" && task backend:get-wavs-submission-mnemonic-$WAVS_INSTANCE)
          OPERATOR_ADDRESS=$(cast wallet address --mnemonic "$OPERATOR_MNEMONIC" --mnemonic-index 0)
          SIGNING_KEY=$(task get-service-signing-address WAVS_INSTANCE=$WAVS_INSTANCE)

          OPERATORS_JSON=$(echo "$OPERATORS_JSON" | jq ". + [\"$OPERATOR_ADDRESS\"]")
          SIGNING_KEYS_JSON=$(echo "$SIGNING_KEYS_JSON" | jq ". + [\"$SIGNING_KEY\"]")
          WEIGHTS_JSON=$(echo "$WEIGHTS_JSON" | jq ". + [{{.WEIGHT}}]")

          echo "Added operator $WAVS_INSTANCE: operator=$OPERATOR_ADDRESS, signingKey=$SIGNING_KEY, weight={{.WEIGHT}}"
        done

        # Create the mock config file JSON from scratch
        jq -n \
          --argjson operators "$OPERATORS_JSON" \
          --argjson signingKeys "$SIGNING_KEYS_JSON" \
          --argjson weights "$WEIGHTS_JSON" \
          --arg threshold "100" \
          --arg quorumNumerator "2" \
          --arg quorumDenominator "3" \
          '{
            operators: $operators,
            signingKeyAddresses: $signingKeys,
            weights: $weights,
            threshold: ($threshold | tonumber),
            quorumNumerator: ($quorumNumerator | tonumber),
            quorumDenominator: ($quorumDenominator | tonumber)
          }' > "{{.NODES_DIR}}/{{.CONFIGURE_FILE}}"

        echo "Mock config written to {{.NODES_DIR}}/{{.CONFIGURE_FILE}} with $(echo "$OPERATORS_JSON" | jq length) operators"

  build-empty-service:
    desc: "Build the empty service configuration"
    deps: [clean-service]
    vars:
      SERVICE_JSON_CMD: 'service --json true --home /wavs-home --file "{{.WAVS_CLI_SERVICE_JSON_PATH}}"'
      SOURCE_CHAIN:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-chain-name-{{.SOURCE_CHAIN_NUMBER}}
      SERVICE_MANAGER_ADDRESS:
        sh: task get-service-manager-address
    requires:
      vars:
        [
          REPO_ROOT,
          COMPONENT_NAME,
          SERVICE_OUTPUT_DIR,
          WAVS_CLI_SERVICE_JSON_PATH,
          SOURCE_CHAIN_NUMBER,
        ]
    cmds:
      - |
        cd "{{.REPO_ROOT}}"
        mkdir -p {{.SERVICE_OUTPUT_DIR}}

        task cli:wavs -- {{.SERVICE_JSON_CMD}} init --name {{.COMPONENT_NAME}}

        task cli:wavs -- {{.SERVICE_JSON_CMD}} manager set-evm --chain {{.SOURCE_CHAIN}} --address {{.SERVICE_MANAGER_ADDRESS}}

        echo "Service configuration built successfully"

  clean-service:
    desc: "Cleans up the service configuration"
    requires:
      vars: [SERVICE_OUTPUT_DIR]
    cmds:
      - rm -rf "{{.SERVICE_OUTPUT_DIR}}"

  upload-service:
    desc: "Upload service configuration to WAVS endpoint"
    vars:
      WAVS_INSTANCE: "{{.WAVS_INSTANCE | default 1}}"
      WAVS_ENDPOINT:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-wavs-endpoint-{{.WAVS_INSTANCE}}
    requires:
      vars: [REPO_ROOT, SERVICE_JSON_PATH, TEMP_SERVICE_HASH_JSON_PATH]
    cmds:
      - >
        curl --fail-with-body -X POST "{{.WAVS_ENDPOINT}}/dev/services" 
        -H "Content-Type: application/json" 
        --data-binary "@{{.SERVICE_JSON_PATH}}"
        -o "{{.TEMP_SERVICE_HASH_JSON_PATH}}"

  set-service-uri:
    vars:
      WAVS_INSTANCE: "{{.WAVS_INSTANCE | default 1}}"
      WAVS_ENDPOINT:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-wavs-endpoint-{{.WAVS_INSTANCE}}
      CHAIN_NUMBER: "{{.SOURCE_CHAIN_NUMBER | default 1}}"
      SERVICE_MANAGER_ADDRESS:
        sh: cd "{{.REPO_ROOT}}" && task middleware:get-service-manager-address CHAIN_NUMBER={{.CHAIN_NUMBER}} PROJECT={{.PROJECT}} SERVICE_NAME={{.PROJECT}}
      TEMP_SERVICE_HASH:
        sh: task get-temp-service-hash
      SERVICE_URI: "{{.WAVS_ENDPOINT}}/dev/services/{{.TEMP_SERVICE_HASH}}"
    cmds:
      - cd "{{.REPO_ROOT}}" && task middleware:set-service-uri CHAIN_NUMBER="{{.CHAIN_NUMBER}}" PROJECT="{{.PROJECT}}" SERVICE_NAME="{{.PROJECT}}" SERVICE_MANAGER_ADDRESS="{{.SERVICE_MANAGER_ADDRESS}}" SERVICE_URI="{{.SERVICE_URI}}"

  register-service:
    vars:
      WAVS_INSTANCE: "{{.WAVS_INSTANCE | default 1}}"
      WAVS_ENDPOINT:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-wavs-endpoint-{{.WAVS_INSTANCE}}
      SERVICE_MANAGER_ADDRESS:
        sh: task get-service-manager-address
      SOURCE_CHAIN_NUMBER: "{{.SOURCE_CHAIN_NUMBER | default 1}}"
      CHAIN_NAME:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-chain-name-{{.SOURCE_CHAIN_NUMBER}}
    cmds:
      - >
        curl --fail-with-body -X POST "{{.WAVS_AGGREGATOR_ENDPOINT}}/services" 
        -H "Content-Type: application/json" 
        -d "{
          \"service_manager\": {
            \"evm\": {
              \"chain\": \"{{.CHAIN_NAME}}\",
              \"address\": \"{{.SERVICE_MANAGER_ADDRESS}}\"
            }
          }
        }"

  deploy-service:
    vars:
      WAVS_INSTANCE: "{{.WAVS_INSTANCE | default 1}}"
      WAVS_ENDPOINT:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-wavs-endpoint-{{.WAVS_INSTANCE}}
      TEMP_SERVICE_HASH:
        sh: task get-temp-service-hash
      SERVICE_URI: "{{.WAVS_ENDPOINT}}/dev/services/{{.TEMP_SERVICE_HASH}}"
    cmds:
      - task cli:wavs -- deploy-service --home /wavs-home --service-uri {{.SERVICE_URI}} --wavs-endpoint {{.WAVS_ENDPOINT}}

  register-operator:
    vars:
      WAVS_INSTANCE: "{{.WAVS_INSTANCE | default 1}}"
      WAVS_SIGNING_KEY:
        sh: task get-service-signing-address WAVS_INSTANCE="{{.WAVS_INSTANCE}}"
      MIDDLEWARE_MODE: '{{.MIDDLEWARE_MODE | default "EIGEN_ECDSA"}}'
    cmds:
      - |
        case "{{.MIDDLEWARE_MODE}}" in
          "EIGEN_MOCK")
            task bootstrap:build-mock-config PROJECT="{{.PROJECT}}"
            cd "{{.REPO_ROOT}}" && task middleware:mock:configure PROJECT="{{.PROJECT}}" SERVICE_NAME="{{.PROJECT}}"
            ;;
          "POA")
            OPERATOR=$(task get-operator-address WAVS_INSTANCE="{{.WAVS_INSTANCE}}")
            SIGNING_KEY=$(task get-service-signing-key WAVS_INSTANCE="{{.WAVS_INSTANCE}}")
            OPERATOR_KEY=$(task get-operator-private-key WAVS_INSTANCE="{{.WAVS_INSTANCE}}")
            cd "{{.REPO_ROOT}}"
            task middleware:poa:register-operator PROJECT="{{.PROJECT}}" SERVICE_NAME="{{.PROJECT}}" OPERATOR_ADDRESS="${OPERATOR}" WEIGHT=100
            task middleware:poa:update-signing-key PROJECT="{{.PROJECT}}" SERVICE_NAME="{{.PROJECT}}" OPERATOR_KEY="${OPERATOR_KEY}" SIGNING_KEY="${SIGNING_KEY}"
            ;;
          *)
            cd "{{.REPO_ROOT}}" && task middleware:eigen:ecdsa:register-operator WAVS_SIGNING_KEY="{{.WAVS_SIGNING_KEY}}" AMOUNT="0.001ether" PROJECT="{{.PROJECT}}" SERVICE_NAME="{{.PROJECT}}" WAVS_INSTANCE="{{.WAVS_INSTANCE}}"
            ;;
        esac

  deploy-service-*:
    vars:
      FIRST_OPERATOR: "{{.FIRST_OPERATOR | default 1}}"
      WAVS_INSTANCE: "{{index .MATCH 0}}"
      WAVS_ENDPOINT:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-wavs-endpoint-{{.WAVS_INSTANCE}}
      TEMP_SERVICE_HASH:
        sh: task get-temp-service-hash
      SOURCE_WAVS_ENDPOINT:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-wavs-endpoint-{{.FIRST_OPERATOR}}
      SERVICE_URI: "{{.SOURCE_WAVS_ENDPOINT}}/dev/services/{{.TEMP_SERVICE_HASH}}"
    cmds:
      - task cli:wavs WAVS_INSTANCE={{.WAVS_INSTANCE}} -- deploy-service --home /wavs-home --service-uri {{.SERVICE_URI}} --wavs-endpoint {{.WAVS_ENDPOINT}}

  get-aggregator-config-values:
    desc: "Get the aggregators config values"
    requires:
      vars: [AGGREGATOR_PROJECT]
    cmds:
      - |
        case "{{.AGGREGATOR_PROJECT}}" in
          "aggregator-simple")
            # Output the config vars in the expected format
            AGGREGATOR_FLAGS=$(task get-aggregator-simple-flags)
            echo "${AGGREGATOR_FLAGS}"
            ;;
          *)
            echo "Error: Unsupported aggregator project '{{.AGGREGATOR_PROJECT}}'. Only 'aggregator-simple' is supported." >&2
            exit 1
            ;;
        esac

  wavs-*:
    vars:
      WAVS_INSTANCE: "{{index .MATCH 0}}"
      MIDDLEWARE_MODE: '{{.MIDDLEWARE_MODE | default "EIGEN_ECDSA"}}'
    cmds:
      - task bootstrap:components-upload WAVS_INSTANCE="{{.WAVS_INSTANCE}}"
      - task bootstrap:deploy-service-{{.WAVS_INSTANCE}}
      - |
        if [ "{{.MIDDLEWARE_MODE}}" != "EIGEN_MOCK" ]; then
          task bootstrap:register-operator WAVS_INSTANCE="{{.WAVS_INSTANCE}}"
        fi

  wavs-all:
    vars:
      FIRST_OPERATOR: "{{.FIRST_OPERATOR | default 1}}"
    cmds:
      - |
        for OPERATOR in $(seq 1 {{.ACTIVE_WAVS_COUNT}}); do
          if [ "$OPERATOR" -ne {{.FIRST_OPERATOR}} ]; then
            task bootstrap:wavs-$OPERATOR FIRST_OPERATOR="{{.FIRST_OPERATOR}}"
          fi
        done
