version: "3"

includes:
  config:
    taskfile: ./config.yml
    flatten: true

env:
  # avoid namespace conflicts with other env vars
  # see https://github.com/go-task/task/issues/1038
  COMPOSE_FOUNDRY_DOCKER_IMAGE: "{{.FOUNDRY_DOCKER_IMAGE}}"
  COMPOSE_WAVS_DOCKER_IMAGE: "{{.WAVS_DOCKER_IMAGE}}"
  COMPOSE_JAEGER_DOCKER_IMAGE: "{{.JAEGER_DOCKER_IMAGE}}"
  COMPOSE_PROMETHEUS_DOCKER_IMAGE: "{{.PROMETHEUS_DOCKER_IMAGE}}"
  COMPOSE_WAVS_HOME: "{{.WAVS_HOME_DIR}}"

tasks:
  start:
    desc: "Starts all backend services"
    deps:
      - task: start-chains
        vars:
          CHAIN_COUNT: "{{.CHAIN_COUNT}}"
      - task: start-wavs
      - task: start-telemetry

  stop:
    desc: "Stops all backend services"
    deps:
      - task: stop-chains
      - task: stop-wavs
      - task: stop-telemetry

  ###################################################################
  ######################## Chains ###################################
  ###################################################################
  start-chains:
    # Pull the latest images before starting
    deps: [docker-pull-chains]
    cmds:
      - task: start-chains-inner
        # Optional - pass this in, or 1 by default
        vars:
          CHAIN_COUNT: '{{.CHAIN_COUNT | default "1"}}'

  stop-chains:
    vars:
      CHAIN_COUNT:
        # look up how many docker containers start with the name "chain-anvil-"
        # this is a bit of a hack, but it works for now
        sh: docker ps --filter "name=chain-anvil-" --format "{{.Names}}" | wc -l | xargs
    cmds:
      - |
        if [ {{.CHAIN_COUNT}} -gt 0 ]; then
          task backend:stop-chains-inner CHAIN_COUNT={{.CHAIN_COUNT}}
        else
          echo "No chains to stop (CHAIN_COUNT={{.CHAIN_COUNT}})"
        fi

  stop-chains-inner:
    requires:
      vars: [CHAIN_COUNT]
    vars:
      # Automatically generated range for CHAIN_COUNT
      CHAIN_RANGE:
        sh: seq 1 {{.CHAIN_COUNT}}
    deps:
      # All of these are stopped in parallel
      - for: { var: CHAIN_RANGE }
        task: docker-stop-chain-{{.ITEM}}

  start-chains-inner:
    internal: true
    vars:
      # Automatically generated range for CHAIN_COUNT
      CHAIN_RANGE:
        sh: seq 1 {{.CHAIN_COUNT}}
    requires:
      vars: [CHAIN_COUNT]
    deps:
      # All of these are started in parallel
      - for: { var: CHAIN_RANGE }
        task: start-chain-{{.ITEM}}

  start-chain-*:
    internal: true
    vars:
      CHAIN_NUMBER: "{{index .MATCH 0}}"
      ANVIL_PORT:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-anvil-port-{{.CHAIN_NUMBER}}
    deps:
      - task: docker-start-chain-{{index .MATCH 0}}
    cmds:
      # Wait for the Anvil chain to be up and running
      # The deps here will ensure that the docker-start-chain-* task is run first
      - |
        for ((i=0; i<5; i++)); do
          if nc -z 127.0.0.1 {{.ANVIL_PORT}}; then
            break
          fi
          echo "Waiting for Anvil chain #{{.CHAIN_NUMBER}} to start on port {{.ANVIL_PORT}}..."
          sleep 1
        done
        if ! nc -z 127.0.0.1 {{.ANVIL_PORT}}; then
          echo "Anvil did not start after 5 seconds"
          exit 1
        fi
      - |
        echo "Anvil chain #{{.CHAIN_NUMBER}} is up!"

  docker-pull-chains:
    internal: true
    cmds:
      - |
        cd "{{.BACKEND_DIR}}" && {{.DOCKER_SUDO}} docker compose --file docker-compose-anvil.yml pull

  docker-start-chain-*:
    internal: true
    vars:
      CHAIN_NUMBER: "{{index .MATCH 0}}"
    env:
      COMPOSE_ANVIL_FORK_CMD:
        # For right now, the setup is that chain #1 is the Holesky fork, and all others are local Anvil instances.
        # We can add more fork URLs here as needed or move this to a map, json, or other structure in the future.
        sh: |
          case {{.CHAIN_NUMBER}} in
            1) echo "--fork-url {{.ANVIL_HOLESKY_FORK_URL}}" ;;
            *) echo "" ;;
          esac
      COMPOSE_CONTAINER_NAME: "chain-anvil-{{.CHAIN_NUMBER}}"
      COMPOSE_ANVIL_PORT:
        sh: cd "{{.REPO_ROOT}}" && task backend:get-anvil-port-{{.CHAIN_NUMBER}}
    cmds:
      - |
        cd "{{.BACKEND_DIR}}" && {{.DOCKER_SUDO}} docker compose --file docker-compose-anvil.yml up --force-recreate -d

  docker-stop-chain-*:
    internal: true
    vars:
      CHAIN_NUMBER: "{{index .MATCH 0}}"
    env:
      COMPOSE_CONTAINER_NAME: "chain-anvil-{{.CHAIN_NUMBER}}"
    cmds:
      - |
        echo "Stopping Anvil chain #{{.CHAIN_NUMBER}}"
      - |
        cd "{{.BACKEND_DIR}}" && {{.DOCKER_SUDO}} docker compose --file docker-compose-anvil.yml down --remove-orphans || true

  # HELPERS
  get-anvil-port-*:
    desc: "Get the Anvil port for a chain number"
    vars:
      CHAIN_NUMBER: "{{index .MATCH 0}}"
      # We use 1 as the CHAIN_NUMBER, so subtract 1 to keep the base port the same
      ANVIL_PORT: "{{sub (add .ANVIL_BASE_PORT .CHAIN_NUMBER) 1}}"
    cmds:
      - echo "{{.ANVIL_PORT}}"

  get-evm-rpc-url-*:
    desc: "Get the RPC URL for a chain number"
    vars:
      CHAIN_NUMBER: "{{index .MATCH 0}}"
      ANVIL_PORT:
        sh: cd "{{.REPO_ROOT}}" && task -s backend:get-anvil-port-{{.CHAIN_NUMBER}}
    cmds:
      - echo "http://localhost:{{.ANVIL_PORT}}"

  ###################################################################
  ######################## WAVS #####################################
  ###################################################################
  start-wavs:
    # Pull the latest images before starting
    deps: [docker-pull-wavs]
    cmds:
      - task: start-wavs-inner

  docker-pull-wavs:
    internal: true
    cmds:
      - |
        cd "{{.BACKEND_DIR}}" && {{.DOCKER_SUDO}} docker compose --file docker-compose-wavs.yml pull

  start-wavs-inner:
    internal: true
    deps: [docker-start-wavs]
    cmds:
      # Wait for WAVS and WAVS Aggregator to be up and running
      # the deps here will ensure that the docker-start-wavs task is run first
      - |
        for ((i=0; i<5; i++)); do
          if nc -z 127.0.0.1 {{.WAVS_AGGREGATOR_PORT}}; then
            break
          fi
          echo "Waiting for Aggregator to start on port {{.WAVS_AGGREGATOR_PORT}}..."
          sleep 1
        done
        if ! nc -z 127.0.0.1 {{.WAVS_AGGREGATOR_PORT}}; then
          echo "Aggregator did not start after 5 seconds"
          exit 1
        fi
      - echo "Aggregator is up!"
      - |
        for ((i=0; i<5; i++)); do
          if nc -z 127.0.0.1 {{.WAVS_PORT}}; then
            break
          fi
          echo "Waiting for WAVS to start on port {{.WAVS_PORT}}..."
          sleep 1
        done
        if ! nc -z 127.0.0.1 {{.WAVS_PORT}}; then
          echo "WAVS did not start after 5 seconds"
          exit 1
        fi
      - echo "WAVS is up!"

  docker-start-wavs:
    internal: true
    cmds:
      - |
        echo "Starting WAVS on port {{.WAVS_PORT}} and WAVS Aggregator on port {{.WAVS_AGGREGATOR_PORT}}"
      - |
        cd "{{.BACKEND_DIR}}" && {{.DOCKER_SUDO}} docker compose --file docker-compose-wavs.yml up --force-recreate -d

  docker-stop-wavs:
    aliases: [stop-wavs]
    cmds:
      - |
        echo "Stopping WAVS"
      - |
        cd "{{.BACKEND_DIR}}" && {{.DOCKER_SUDO}} docker compose --file docker-compose-wavs.yml down --remove-orphans || true

  ###################################################################
  ##################### TELEMETRY ###################################
  ###################################################################

  start-telemetry:
    # Pull the latest images before starting
    deps: [docker-pull-telemetry]
    cmds:
      - task: start-telemetry-inner

  docker-pull-telemetry:
    internal: true
    cmds:
      - |
        cd "{{.BACKEND_DIR}}" && {{.DOCKER_SUDO}} docker compose --file docker-compose-telemetry.yml pull

  start-telemetry-inner:
    internal: true
    deps: [docker-start-telemetry]
    cmds:
      # Wait for Jaeger and Prometheus to be up and running
      # the deps here will ensure that the docker-start-telemetry task is run first
      - |
        while ! nc -z localhost 16686; do
          echo "Waiting for Jaeger to start on port 16686..."
          sleep 1
        done
      - echo "Jaeger is up and running!"
      - |
        while ! nc -z localhost 9090; do
          echo "Waiting for Prometheus to start on port 9090..."
          sleep 1
        done
      - echo "Prometheus is up and running!"

  docker-start-telemetry:
    internal: true
    cmds:
      - echo "Starting Telemetry"
      - cd "{{.BACKEND_DIR}}" && {{.DOCKER_SUDO}} docker compose --file docker-compose-telemetry.yml up --force-recreate -d

  docker-stop-telemetry:
    aliases: [stop-telemetry]
    cmds:
      - echo "Stopping Telemetry"
      - cd "{{.BACKEND_DIR}}" && {{.DOCKER_SUDO}} docker compose --file docker-compose-telemetry.yml down --remove-orphans || true
