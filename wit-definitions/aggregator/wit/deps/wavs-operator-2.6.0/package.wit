package wavs:operator@2.6.0;

interface input {
  use wavs:types/service@2.6.0.{service-id, workflow-id, trigger};
  use wavs:types/events@2.6.0.{trigger-data};

  record trigger-config {
    service-id: service-id,
    workflow-id: workflow-id,
    trigger: trigger,
  }

  record trigger-action {
    config: trigger-config,
    data: trigger-data,
  }
}

interface output {
  use wavs:types/events@2.6.0.{event-id};

  record wasm-response {
    /// arbitrary payload returned from the component
    /// and passed on to be signed by the operators
    payload: list<u8>,
    /// currently unused
    ordering: option<u64>,
    /// if not supplied, this will be `trigger-data`
    /// if supplied, make sure this is unique for every response!
    /// for example, using a "message id" from a third-party service
    /// also, it MUST be supplied if multiple responses are returned
    event-id-salt: option<list<u8>>,
  }
}

world wavs-world {
  import wavs:types/core@2.6.0;
  import wavs:types/chain@2.6.0;
  import wavs:types/service@2.6.0;
  import wavs:types/events@2.6.0;
  import input;
  import output;
  import wasi:io/poll@0.2.0;
  import wasi:clocks/monotonic-clock@0.2.0;
  import wasi:io/error@0.2.0;
  import wasi:io/streams@0.2.0;
  import wasi:http/types@0.2.0;
  import wasi:http/outgoing-handler@0.2.0;
  import host: interface {
    use wavs:types/chain@2.6.0.{evm-chain-config, cosmos-chain-config};
    use wavs:types/service@2.6.0.{service-and-workflow-id, workflow-and-workflow-id};
    use wavs:types/core@2.6.0.{log-level};
    use wavs:types/events@2.6.0.{event-id};

    get-evm-chain-config: func(chain-key: string) -> option<evm-chain-config>;

    get-cosmos-chain-config: func(chain-key: string) -> option<cosmos-chain-config>;

    config-var: func(key: string) -> option<string>;

    log: func(level: log-level, message: string);

    /// gets the service and workflow id that called this component
    get-service: func() -> service-and-workflow-id;

    /// convenience function to get the workflow without having to walk service.workflows
    get-workflow: func() -> workflow-and-workflow-id;

    /// convenience function to get what the event id will be
    /// typically only used for debugging or testing purposes
    get-event-id: func(salt: option<list<u8>>) -> event-id;
  }
  import wasi:cli/environment@0.2.0;
  import wasi:cli/exit@0.2.0;
  import wasi:cli/stdin@0.2.0;
  import wasi:cli/stdout@0.2.0;
  import wasi:cli/stderr@0.2.0;
  import wasi:cli/terminal-input@0.2.0;
  import wasi:cli/terminal-output@0.2.0;
  import wasi:cli/terminal-stdin@0.2.0;
  import wasi:cli/terminal-stdout@0.2.0;
  import wasi:cli/terminal-stderr@0.2.0;
  import wasi:clocks/wall-clock@0.2.0;
  import wasi:filesystem/types@0.2.0;
  import wasi:filesystem/preopens@0.2.0;
  import wasi:sockets/network@0.2.0;
  import wasi:sockets/instance-network@0.2.0;
  import wasi:sockets/udp@0.2.0;
  import wasi:sockets/udp-create-socket@0.2.0;
  import wasi:sockets/tcp@0.2.0;
  import wasi:sockets/tcp-create-socket@0.2.0;
  import wasi:sockets/ip-name-lookup@0.2.0;
  import wasi:random/random@0.2.0;
  import wasi:random/insecure@0.2.0;
  import wasi:random/insecure-seed@0.2.0;
  import wasi:keyvalue/store@0.2.0-draft2;
  import wasi:keyvalue/atomics@0.2.0-draft2;
  import wasi:keyvalue/batch@0.2.0-draft2;
  @unstable(feature = tls)
  import wasi:tls/types@0.2.0-draft;
  use input.{trigger-action};
  use output.{wasm-response};

  /// if returning multiple responses, they must all have an event-id-salt
  export run: func(trigger-action: trigger-action) -> result<list<wasm-response>, string>;
}
