version: "3"

dotenv: [".env", ".docker/.state.env"]

vars:
  COMPONENTS_DIR: "./compiled"
  STATE_DIR: ".docker"

  # ===========================================
  # DOCKER IMAGE TAGS - Change these to use different versions
  # ===========================================
  WAVS_DOCKER_TAG: "35c96a4" # WAVS main image tag
  WAVS_MIDDLEWARE_DOCKER_TAG: "0.4.0-rc" # WAVS middleware image tag
  WARG_REGISTRY_DOCKER_TAG: "v0.9.3" # WARG registry image tag

  # Default environment settings (can be overridden with env vars)
  DEPLOY_ENV: '{{.DEPLOY_ENV | default "LOCAL"}}'
  RPC_URL: '{{.RPC_URL | default "http://localhost:8545"}}'

includes:
  avs_sync: ./tools/avs_sync/Taskfile.yml

tasks:
  # ===========================================
  # PUBLIC TASKS (Main user-facing commands)
  # ===========================================

  start:
    desc: "Start anvil and core services"
    deps: [check-prerequisites, init-environment]
    cmds:
      - task: start-services-background
      - task: deploy-middleware

  stop:
    desc: "Stop Anvil and Docker services"
    env:
      WARG_REGISTRY_DOCKER_TAG: "{{.WARG_REGISTRY_DOCKER_TAG}}"
    cmds:
      - docker compose -f docker-compose.yml -f telemetry/docker-compose.yml down --remove-orphans || true
      - pkill -f "anvil --fork-url" || true
      - warg reset

  restart:
    desc: "Restart Anvil and Docker services"
    cmds:
      - task stop
      - task start

  show-versions:
    desc: "Show current Docker image versions being used"
    cmds:
      - |
        echo "üê≥ Current Docker Image Tags:"
        echo "  WAVS Main:       ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}"
        echo "  WAVS Middleware: ghcr.io/lay3rlabs/wavs-middleware:{{.WAVS_MIDDLEWARE_DOCKER_TAG}}"
        echo "  WARG Registry:   ghcr.io/reecepbcups/warg-registry:{{.WARG_REGISTRY_DOCKER_TAG}}"
        echo ""
        echo "üí° To change versions, edit the vars section at the top of Taskfile.yml"

  deploy-component:
    desc: "Deploy a component (usage: task deploy-component COMPONENT=<name>)"
    deps: [init-environment]
    cmds:
      - |
        if [ -z "{{.COMPONENT}}" ]; then
          echo "ERROR: COMPONENT parameter is required. Usage: task deploy-component COMPONENT=<name>"
          exit 1
        fi
        echo "Deploying component: {{.COMPONENT}}"
      - task: deploy-middleware
      - task: deploy-component-workflow
        vars:
          COMPONENT: "{{.COMPONENT}}"

  create-aggregator:
    desc: "Create aggregator instance (usage: task create-aggregator INDEX=<n>)"
    deps: [init-environment]
    vars:
      INDEX: "{{.INDEX | default 1}}"
    cmds:
      - task: create-aggregator-instance
        vars:
          INDEX: "{{.INDEX}}"

  create-operator:
    desc: "Create operator instance (usage: task create-operator INDEX=<n>)"
    deps: [init-environment]
    vars:
      INDEX: "{{.INDEX | default 1}}"
    cmds:
      - task: create-operator-instance
        vars:
          INDEX: "{{.INDEX}}"

  wavs-middleware:
    desc: "Run wavs middleware command"
    deps: [init-environment]
    vars:
      STATE_DIR: ".docker"
      MIDDLEWARE_DOCKER_IMAGE: "ghcr.io/lay3rlabs/wavs-middleware:{{.WAVS_MIDDLEWARE_DOCKER_TAG}}"
    env:
      DEPLOYER_ADDRESS: '{{.DEPLOYER_ADDRESS | default ""}}'
      DEPLOYER_PRIVATE_KEY: '{{.DEPLOYER_PRIVATE_KEY | default ""}}'
      WAVS_SERVICE_MANAGER_ADDRESS: '{{.WAVS_SERVICE_MANAGER_ADDRESS | default ""}}'
      ECDSA_STAKE_REGISTRY_ADDRESS: '{{.ECDSA_STAKE_REGISTRY_ADDRESS | default ""}}'
    cmds:
      - |
        # Build environment args for Docker
        ENV_ARGS=""
        [ -n "$DEPLOYER_ADDRESS" ] && ENV_ARGS="$ENV_ARGS -e DEPLOYER_ADDRESS=$DEPLOYER_ADDRESS"
        [ -n "$DEPLOYER_PRIVATE_KEY" ] && ENV_ARGS="$ENV_ARGS -e DEPLOYER_PRIVATE_KEY=$DEPLOYER_PRIVATE_KEY"
        [ -n "$WAVS_SERVICE_MANAGER_ADDRESS" ] && ENV_ARGS="$ENV_ARGS -e WAVS_SERVICE_MANAGER_ADDRESS=$WAVS_SERVICE_MANAGER_ADDRESS"
        [ -n "$ECDSA_STAKE_REGISTRY_ADDRESS" ] && ENV_ARGS="$ENV_ARGS -e ECDSA_STAKE_REGISTRY_ADDRESS=$ECDSA_STAKE_REGISTRY_ADDRESS"

        docker run --rm --network host \
          $ENV_ARGS --env-file .env \
          -v ./.nodes:/root/.nodes {{.MIDDLEWARE_DOCKER_IMAGE}} {{.CLI_ARGS}}

  wavs-cli:
    desc: "Run wavs cli command"
    vars:
      WAVS_DOCKER_IMAGE: "ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}"
      INSTANCE: '{{.INSTANCE | default "wavs-1"}}'
      CLI_ARGS: '{{.CLI_ARGS | default ""}}'
    env:
      WAVS_CLI_EVM_CREDENTIAL: '{{.WAVS_CLI_EVM_CREDENTIAL | default ""}}'
      WAVS_SUBMISSION_MNEMONIC: '{{.WAVS_SUBMISSION_MNEMONIC | default ""}}'
      DEPLOYER_ADDRESS: '{{.DEPLOYER_ADDRESS | default ""}}'
      DEPLOYER_PRIVATE_KEY: '{{.DEPLOYER_PRIVATE_KEY | default ""}}'
      WAVS_SERVICE_MANAGER_ADDRESS: '{{.WAVS_SERVICE_MANAGER_ADDRESS | default ""}}'
      ECDSA_STAKE_REGISTRY_ADDRESS: '{{.ECDSA_STAKE_REGISTRY_ADDRESS | default ""}}'
    cmds:
      - |
        # Build environment args for Docker
        ENV_ARGS=""
        [ -n "$WAVS_CLI_EVM_CREDENTIAL" ] && ENV_ARGS="$ENV_ARGS -e WAVS_CLI_EVM_CREDENTIAL=$WAVS_CLI_EVM_CREDENTIAL"
        [ -n "$WAVS_SUBMISSION_MNEMONIC" ] && ENV_ARGS="$ENV_ARGS -e WAVS_SUBMISSION_MNEMONIC=$WAVS_SUBMISSION_MNEMONIC"
        [ -n "$DEPLOYER_ADDRESS" ] && ENV_ARGS="$ENV_ARGS -e DEPLOYER_ADDRESS=$DEPLOYER_ADDRESS"
        [ -n "$DEPLOYER_PRIVATE_KEY" ] && ENV_ARGS="$ENV_ARGS -e DEPLOYER_PRIVATE_KEY=$DEPLOYER_PRIVATE_KEY"
        [ -n "$WAVS_SERVICE_MANAGER_ADDRESS" ] && ENV_ARGS="$ENV_ARGS -e WAVS_SERVICE_MANAGER_ADDRESS=$WAVS_SERVICE_MANAGER_ADDRESS"
        [ -n "$ECDSA_STAKE_REGISTRY_ADDRESS" ] && ENV_ARGS="$ENV_ARGS -e ECDSA_STAKE_REGISTRY_ADDRESS=$ECDSA_STAKE_REGISTRY_ADDRESS"

        docker run --rm --network host \
          $ENV_ARGS \
          -w /data -v $(pwd):/data {{.WAVS_DOCKER_IMAGE}} \
          wavs-cli {{.CLI_ARGS}}

  # ===========================================
  # CORE TASKS (Setup and utilities)
  # ===========================================

  init-environment:
    desc: "Initialize environment and state files"
    cmds:
      - mkdir -p {{.STATE_DIR}}
      - |
        [ -f .env ] || cp .env.example .env
      - |
        # Always create fresh state file
        > {{.STATE_DIR}}/.state.env
      - task: update-state-from-artifacts

  update-state-from-artifacts:
    desc: "Update state from deployment artifacts"
    cmds:
      - |
        # Update state from JSON artifacts

        # Load deployer info
        if [ -f {{.STATE_DIR}}/deployer.json ]; then
          DEPLOYER_ADDRESS=$(jq -r '.accounts[0].address' {{.STATE_DIR}}/deployer.json)
          DEPLOYER_PRIVATE_KEY=$(jq -r '.accounts[0].private_key' {{.STATE_DIR}}/deployer.json)
          echo "DEPLOYER_ADDRESS=${DEPLOYER_ADDRESS}" >> {{.STATE_DIR}}/.state.env
          echo "DEPLOYER_PRIVATE_KEY=${DEPLOYER_PRIVATE_KEY}" >> {{.STATE_DIR}}/.state.env
          echo "Loaded deployer info into state"
        fi

        # Load middleware deployment info
        if [ -f .nodes/avs_deploy.json ]; then
          WAVS_SERVICE_MANAGER_ADDRESS=$(jq -r '.addresses.WavsServiceManager' .nodes/avs_deploy.json)
          ECDSA_STAKE_REGISTRY_ADDRESS=$(jq -r '.addresses.stakeRegistry' .nodes/avs_deploy.json)
          echo "WAVS_SERVICE_MANAGER_ADDRESS=${WAVS_SERVICE_MANAGER_ADDRESS}" >> {{.STATE_DIR}}/.state.env
          echo "ECDSA_STAKE_REGISTRY_ADDRESS=${ECDSA_STAKE_REGISTRY_ADDRESS}" >> {{.STATE_DIR}}/.state.env
          echo "Loaded middleware deployment info into state"
        fi

  start-services:
    desc: "Start anvil and Docker services based on DEPLOY_ENV"
    cmds:
      - |
        export WARG_REGISTRY_DOCKER_TAG={{.WARG_REGISTRY_DOCKER_TAG}}

        if [ -f .env ] && grep -q '^TESTNET_RPC_URL=' .env; then
          TESTNET_RPC_URL=$(grep -E '^TESTNET_RPC_URL=' .env | cut -d '=' -f2- | tr -d '"')
        else
          rpc_url="https://holesky.drpc.org"
          echo "No TESTNET_RPC_URL found in .env, using default ${rpc_url}"
          TESTNET_RPC_URL=${rpc_url}
        fi

        PORT=8545
        FORK_RPC_URL=${FORK_RPC_URL:-"${TESTNET_RPC_URL}"}

        if [ "{{.DEPLOY_ENV}}" = "TESTNET" ]; then
          echo "Running in testnet mode, nothing to do"
          exit 0
        fi

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          anvil --fork-url ${FORK_RPC_URL} --port ${PORT} &
          anvil_pid=$!
          trap "kill -9 $anvil_pid && echo -e '\nKilled anvil'" EXIT
          while ! cast block-number --rpc-url http://localhost:${PORT} > /dev/null 2>&1
          do
            sleep 0.25
          done

          FILES="-f docker-compose.yml -f telemetry/docker-compose.yml"
          docker compose ${FILES} pull
          docker compose ${FILES} up --force-recreate -d
          trap "docker compose ${FILES} down --remove-orphans && docker kill wavs-1 wavs-aggregator-1 > /dev/null 2>&1 && echo -e '\nKilled IPFS + Local WARG, and wavs instances'" EXIT

          echo "Started..."
          wait
        fi

  start-services-background:
    desc: "Start anvil and Docker services in background"
    cmds:
      - |
        export WARG_REGISTRY_DOCKER_TAG={{.WARG_REGISTRY_DOCKER_TAG}}

        if [ -f .env ] && grep -q '^TESTNET_RPC_URL=' .env; then
          TESTNET_RPC_URL=$(grep -E '^TESTNET_RPC_URL=' .env | cut -d '=' -f2- | tr -d '"')
        else
          rpc_url="https://holesky.drpc.org"
          echo "No TESTNET_RPC_URL found in .env, using default ${rpc_url}"
          TESTNET_RPC_URL=${rpc_url}
        fi

        PORT=8545
        FORK_RPC_URL=${FORK_RPC_URL:-"${TESTNET_RPC_URL}"}

        if [ "{{.DEPLOY_ENV}}" = "TESTNET" ]; then
          echo "Running in testnet mode, nothing to do"
          exit 0
        fi

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          # Kill any existing anvil
          pkill -f "anvil --fork-url" || true
          
          # Start anvil in background
          anvil --fork-url ${FORK_RPC_URL} --port ${PORT} &
          
          # Wait for anvil to be ready
          while ! cast block-number --rpc-url http://localhost:${PORT} > /dev/null 2>&1
          do
            sleep 0.25
          done

          FILES="-f docker-compose.yml -f telemetry/docker-compose.yml"
          docker compose ${FILES} pull
          docker compose ${FILES} up --force-recreate -d

          echo "Services started in background"
        fi

  create-deployer:
    desc: "Create and fund deployer wallet"
    deps: [init-environment]
    cmds:
      - |
        mkdir -p .docker

        # Create new deployer
        cast wallet new-mnemonic --json > .docker/deployer.json
        export DEPLOYER_PK=`jq -r .accounts[0].private_key .docker/deployer.json`
        export DEPLOYER_ADDRESS=`cast wallet address $DEPLOYER_PK`

        # Update .env file with deployer key
        if [[ "$(uname)" == *"Darwin"* ]]; then
          sed -i '' -e "s/^FUNDED_KEY=.*$/FUNDED_KEY=$DEPLOYER_PK/" .env
        else
          sed -i -e "s/^FUNDED_KEY=.*$/FUNDED_KEY=$DEPLOYER_PK/" .env
        fi

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          # Auto fund the deployer in local environment
          cast rpc anvil_setBalance "${DEPLOYER_ADDRESS}" '15000000000000000000' --rpc-url {{.RPC_URL}} > /dev/null
          BAL=`cast balance --ether $DEPLOYER_ADDRESS --rpc-url={{.RPC_URL}}`
          echo "Local deployer \`${DEPLOYER_ADDRESS}\` funded with ${BAL}ether"
        else
          # New account on testnet, must be funded externally
          echo "Fund deployer ${DEPLOYER_ADDRESS} with some ETH, or change this value in the .env"
          sleep 5
          
          while true; do
            BALANCE=`cast balance --ether $DEPLOYER_ADDRESS --rpc-url={{.RPC_URL}}`
            if [ "$BALANCE" != "0.000000000000000000" ]; then
              echo "Deployer balance is now $BALANCE"
              break
            fi
            echo "    [!] Waiting for balance to be funded by another account to this deployer..."
            sleep 5
          done
        fi
      - task: update-state-from-artifacts

  # ===========================================
  # INSTANCE CREATION (Simplified)
  # ===========================================

  create-aggregator-instance:
    desc: "Create aggregator instance"
    vars:
      INDEX: "{{.INDEX}}"
      AGG_LOC: "infra/aggregator-{{.INDEX}}"
    cmds:
      - task: generate-wallet-and-setup
        vars:
          WALLET_TYPE: "aggregator"
          INDEX: "{{.INDEX}}"
          TARGET_DIR: "{{.AGG_LOC}}"
      - |
        # Create aggregator start script
        cat > {{.AGG_LOC}}/start.sh << 'EOF'
        #!/bin/bash
        cd $(dirname "$0") || exit 1

        IMAGE=ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}
        INSTANCE=wavs-aggregator-{{.INDEX}}
        IPFS_GATEWAY=${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}

        docker kill ${INSTANCE} > /dev/null 2>&1 || true
        docker rm ${INSTANCE} > /dev/null 2>&1 || true

        docker run -d --name ${INSTANCE} --network host --stop-signal SIGKILL --env-file .env --user 1000:1000 -v .:/wavs \
          ${IMAGE} wavs-aggregator --log-level debug --host 0.0.0.0 --port 8001 --ipfs-gateway ${IPFS_GATEWAY}

        sleep 1
        EOF
        chmod +x {{.AGG_LOC}}/start.sh

  create-operator-instance:
    desc: "Create operator instance"
    vars:
      INDEX: "{{.INDEX}}"
      OP_LOC: "infra/wavs-{{.INDEX}}"
    cmds:
      - task: generate-wallet-and-setup
        vars:
          WALLET_TYPE: "operator"
          INDEX: "{{.INDEX}}"
          TARGET_DIR: "{{.OP_LOC}}"
      - |
        # Create operator start script
        cat > {{.OP_LOC}}/start.sh << 'EOF'
        #!/bin/bash
        cd $(dirname "$0") || exit 1

        IMAGE=ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}
        INSTANCE=wavs-{{.INDEX}}
        IPFS_GATEWAY=${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}

        docker kill ${INSTANCE} > /dev/null 2>&1 || true
        docker rm ${INSTANCE} > /dev/null 2>&1 || true

        docker run -d --name ${INSTANCE} --network host --env-file .env -v .:/root/wavs \
          ${IMAGE} wavs --home /root/wavs --ipfs-gateway ${IPFS_GATEWAY} --host 0.0.0.0 --log-level info

        sleep 1
        EOF
        chmod +x {{.OP_LOC}}/start.sh

  generate-wallet-and-setup:
    desc: "Generate wallet and setup instance directory"
    vars:
      WALLET_TYPE: "{{.WALLET_TYPE}}"
      INDEX: "{{.INDEX}}"
      TARGET_DIR: "{{.TARGET_DIR}}"
    cmds:
      - mkdir -p {{.TARGET_DIR}}
      - |
        # Create .env file
        if [ "{{.WALLET_TYPE}}" = "aggregator" ]; then
          # Generate wallet for aggregator
          TEMP_FILE="{{.STATE_DIR}}/tmp_{{.WALLET_TYPE}}_{{.INDEX}}.json"
          cast wallet new-mnemonic --json > $TEMP_FILE
          MNEMONIC=$(jq -r .mnemonic $TEMP_FILE)
          PRIVATE_KEY=$(jq -r .accounts[0].private_key $TEMP_FILE)
          ADDRESS=$(cast wallet address "$PRIVATE_KEY")
          rm $TEMP_FILE
          
          cat > {{.TARGET_DIR}}/.env << EOF
        # Mnemonic for reference: ${MNEMONIC}
        WAVS_AGGREGATOR_DATA=~/wavs/aggregator
        WAVS_AGGREGATOR_CREDENTIAL="${PRIVATE_KEY}"
        WAVS_AGGREGATOR_HD_INDEX=0
        EOF
        else
          # Use deployer key for operator to ensure contract ownership consistency
          source {{.STATE_DIR}}/.state.env
          # Get the mnemonic from the deployer.json file
          DEPLOYER_MNEMONIC=$(jq -r .mnemonic {{.STATE_DIR}}/deployer.json)
          ADDRESS="${DEPLOYER_ADDRESS}"
          
          cat > {{.TARGET_DIR}}/.env << EOF
        WAVS_SUBMISSION_MNEMONIC="${DEPLOYER_MNEMONIC}"
        WAVS_CLI_EVM_CREDENTIAL="${DEPLOYER_PRIVATE_KEY}"
        EOF
        fi

        # Copy config files
        cp wavs.toml {{.TARGET_DIR}}/wavs.toml

        # Fund wallet if local
        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          cast rpc anvil_setBalance ${ADDRESS} '15000000000000000000' --rpc-url {{.RPC_URL}} > /dev/null
          BAL=$(cast balance --ether ${ADDRESS} --rpc-url={{.RPC_URL}})
          echo "Local {{.WALLET_TYPE}} ${ADDRESS} funded with ${BAL}ether"
        else
          echo "Fund {{.WALLET_TYPE}} ${ADDRESS} with some ETH"
        fi

  # ===========================================
  # DEPLOYMENT WORKFLOW
  # ===========================================

  deploy-middleware:
    desc: "Deploy WAVS middleware contracts"
    deps: [create-deployer]
    cmds:
      - |
        echo "Deploying WAVS middleware..."
      - task: wavs-middleware
        vars:
          CLI_ARGS: "deploy"
      - task: update-state-from-artifacts
      - |
        echo "‚úì Middleware deployed successfully"

  deploy-component-workflow:
    desc: "Complete component deployment workflow"
    vars:
      COMPONENT: "{{.COMPONENT}}"
    cmds:
      - |
        if [ ! -d "tools/{{.COMPONENT}}" ]; then
          echo "‚ùå Component {{.COMPONENT}} not found in tools/"
          exit 1
        fi

        echo "üöÄ Deploying component: {{.COMPONENT}}"

        # 1. Build WASM component
        echo "üì¶ Building WASM component..."
        task build-components COMPONENT={{.COMPONENT}}

        # 2. Deploy component contracts
        echo "üìÑ Deploying component contracts..."
        cd tools/{{.COMPONENT}} && task deploy-contracts && cd ../..

        # 3. Upload to WASI registry
        echo "üì§ Uploading to WASI registry..."
        task upload-component-to-registry COMPONENT={{.COMPONENT}}

        # 4. Build service configuration
        echo "‚öôÔ∏è Building service configuration..."
        (cd tools/{{.COMPONENT}} && task build-service) || true

        # 5. Upload to IPFS
        echo "‚òÅÔ∏è Uploading service to IPFS..."
        IPFS_CID=$(SERVICE_FILE=.docker/service.json task upload-to-ipfs | tail -1)
        IPFS_URI="ipfs://${IPFS_CID}"
        echo "üìç Service uploaded to: ${IPFS_URI}"

        # 6. Start services
        echo "üîÑ Starting aggregator and operator..."
        task start-aggregator-and-operator IPFS_URI="${IPFS_URI}"

        echo "‚úÖ Component {{.COMPONENT}} deployed successfully!"

  upload-component-to-registry:
    desc: "Upload component to WASI registry"
    vars:
      COMPONENT: "{{.COMPONENT}}"
    cmds:
      - |
        PKG_NAMESPACE=$(grep "PKG_NAMESPACE:" tools/{{.COMPONENT}}/Taskfile.yml | head -1 | sed 's/.*PKG_NAMESPACE: *"\([^"]*\)".*/\1/')
        PKG_NAME=$(grep "PKG_NAME:" tools/{{.COMPONENT}}/Taskfile.yml | head -1 | sed 's/.*PKG_NAME: *\([^ ]*\).*/\1/')
        PKG_VERSION=$(grep "PKG_VERSION:" tools/{{.COMPONENT}}/Taskfile.yml | head -1 | sed 's/.*PKG_VERSION: *\([^ ]*\).*/\1/')

        echo "Package: ${PKG_NAMESPACE}:${PKG_NAME}@${PKG_VERSION}"
        PKG_NAMESPACE=${PKG_NAMESPACE} PKG_NAME=${PKG_NAME} PKG_VERSION=${PKG_VERSION} COMPONENT_FILENAME={{.COMPONENT}}.wasm task upload-to-wasi-registry

  upload-to-ipfs:
    desc: Upload a service file to IPFS and return the CID
    vars:
      SERVICE_FILE: '{{.SERVICE_FILE | default ".docker/service.json"}}'
    env:
      PINATA_API_KEY: '{{.PINATA_API_KEY | default ""}}'
    cmds:
      - |
        SERVICE_FILE="{{.SERVICE_FILE}}"
        if [ -z "$SERVICE_FILE" ] || [ ! -f "$SERVICE_FILE" ]; then
          echo "‚ùå SERVICE_FILE not set or does not exist: '$SERVICE_FILE'"
          exit 1
        fi

        echo "üìÑ SERVICE_FILE: $SERVICE_FILE"
        echo "üåç DEPLOY_ENV: {{.DEPLOY_ENV}}"

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          # Use Docker IPFS instance via HTTP API
          if ! curl -s --connect-timeout 5 http://localhost:5001/api/v0/version > /dev/null; then
            echo "‚ùå IPFS not running on localhost:5001"
            exit 1
          fi
          
          ipfs_response=$(curl -s -X POST \
            -F "file=@${SERVICE_FILE}" \
            "http://localhost:5001/api/v0/add?only-hash=false&recursive=false&quiet=true")
          
          if [ $? -eq 0 ] && [ -n "$ipfs_response" ]; then
            ipfs_cid=$(echo "$ipfs_response" | jq -r '.Hash' 2>/dev/null || echo "$ipfs_response" | tail -1)
            if [ -n "$ipfs_cid" ] && [ "$ipfs_cid" != "null" ]; then
              echo "$ipfs_cid"
            else
              echo "‚ùå Failed to extract IPFS hash from response: $ipfs_response" >&2
              exit 1
            fi
          else
            echo "‚ùå Failed to upload to IPFS" >&2
            exit 1
          fi
        elif [ "{{.DEPLOY_ENV}}" = "TESTNET" ]; then
          if [ -z "$PINATA_API_KEY" ]; then
            echo "‚ùå PINATA_API_KEY not set" >&2
            exit 1
          fi
          ipfs_cid=$(curl -s -X POST https://api.pinata.cloud/pinning/pinFileToIPFS \
            -H "Authorization: Bearer $PINATA_API_KEY" \
            -F "file=@${SERVICE_FILE}" | jq -r '.IpfsHash')
          echo "$ipfs_cid"
        else
          echo "‚ùå Unknown DEPLOY_ENV: {{.DEPLOY_ENV}}" >&2
          exit 1
        fi

  build-components:
    desc: "Build all or specific WASM components"
    cmds:
      - |
        COMPONENT="{{.COMPONENT}}"
        if [ -n "$COMPONENT" ]; then
          echo "Building specific component: $COMPONENT"
          if [ -d "tools/$COMPONENT" ]; then
            cd tools/$COMPONENT && task wasi-build && cd ../..
          else
            echo "‚ùå Component $COMPONENT not found in tools/"
            exit 1
          fi
        else
          echo "Building all components..."
          # Build all components with Taskfiles
          RECIPE="wasi-build"
          TASKFILE_DIRS=$(find tools/* -maxdepth 1 -name "Taskfile.yml" 2>/dev/null || true)
          
          if [ -z "$TASKFILE_DIRS" ]; then
            echo "No Taskfile.yml found in tools/*"
            exit 0
          fi
          
          for taskfile_path in $TASKFILE_DIRS; do
            if grep -q "^  ${RECIPE}:" "$taskfile_path" 2>/dev/null; then
              parent_dir=$(dirname "$taskfile_path")
              component_name=$(basename "$parent_dir")
              echo "Building component: $component_name"
              (cd "$parent_dir" && task $RECIPE)
            else
              parent_dir=$(dirname "$taskfile_path")
              component_name=$(basename "$parent_dir")
              echo "Recipe '$RECIPE' not found in $component_name/Taskfile.yml"
            fi
          done
          
          echo "Component build complete"
        fi

  upload-to-wasi-registry:
    desc: "Upload component to WASI registry"
    vars:
      REGISTRY: '{{.DEPLOY_ENV | eq "LOCAL" | ternary "localhost:8090" "wa.dev"}}'
      PKG_NAMESPACE_VAR: '{{.DEPLOY_ENV | eq "LOCAL" | ternary .PKG_NAMESPACE ""}}'
    env:
      PKG_NAME: "{{.PKG_NAME}}"
      PKG_VERSION: "{{.PKG_VERSION}}"
      COMPONENT_FILENAME: "{{.COMPONENT_FILENAME}}"
    cmds:
      - |
        REGISTRY="{{.REGISTRY}}"

        # Get PKG_NAMESPACE based on DEPLOY_ENV
        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          PKG_NAMESPACE="{{.PKG_NAMESPACE_VAR}}"
        else
          read -p "Enter the PKG_NAMESPACE for ${REGISTRY}: " namespace
          PKG_NAMESPACE="${namespace}"
        fi

        if [ -z "$PKG_NAMESPACE" ]; then
            echo "‚ùå PKG_NAMESPACE is not set."
            exit 1
        fi

        # Validate required environment variables
        if [ -z "$PKG_NAME" ] || [ -z "$PKG_VERSION" ] || [ -z "$COMPONENT_FILENAME" ]; then
          echo "‚ùå ERROR: PKG_NAME, PKG_VERSION, and COMPONENT_FILENAME are required"
          echo "  PKG_NAME: $PKG_NAME"
          echo "  PKG_VERSION: $PKG_VERSION"
          echo "  COMPONENT_FILENAME: $COMPONENT_FILENAME"
          exit 1
        fi

        COMPONENT_PATH="{{.COMPONENTS_DIR}}/${COMPONENT_FILENAME}"
        if [ ! -f "$COMPONENT_PATH" ]; then
          echo "‚ùå Component file not found: $COMPONENT_PATH"
          exit 1
        fi

        # Determine protocol
        PROTOCOL="https"
        if [[ "$REGISTRY" == *"localhost"* ]] || [[ "$REGISTRY" == *"127.0.0.1"* ]]; then
            PROTOCOL="http"
        fi

        PACKAGE_NAME="${PKG_NAMESPACE}:${PKG_NAME}"
        echo "üì§ Uploading: $COMPONENT_PATH"
        echo "   To: ${PROTOCOL}://${REGISTRY}/${PACKAGE_NAME}@${PKG_VERSION}"

        # Upload with proper error handling
        set +e  # Don't exit on error
        output=$(warg publish release --registry ${PROTOCOL}://${REGISTRY} --name ${PKG_NAMESPACE}:${PKG_NAME} --version ${PKG_VERSION} ${COMPONENT_PATH} 2>&1)
        exit_code=$?
        warg reset --registry ${PROTOCOL}://${REGISTRY}

        # Check for specific error conditions in the output
        if [[ $exit_code -ne 0 ]]; then
            if [[ "$output" =~ "failed to prove inclusion" ]]; then
                echo "‚úÖ Package uploaded to local registry successfully..."
                echo "   (This is expected for local registries)"
            elif [[ "$output" =~ "error sending request for url" ]]; then
                echo "‚ö†Ô∏è Registry not available - check that you are running the registry locally"
                echo "${output}"
            else
                echo "‚ö†Ô∏è Upload error: ${output}"
            fi
        else
            echo "‚úÖ Package uploaded successfully"
        fi
        set -e  # Re-enable exit on error

        # Registry info no longer stored in state - passed directly to tasks that need it

  start-aggregator-and-operator:
    desc: "Start aggregator and operator services"
    deps: [init-environment]
    env:
      IPFS_URI: "{{.IPFS_URI}}"
    cmds:
      - |
        # Read state file to get deployer credentials
        [ -f {{.STATE_DIR}}/.state.env ] && source {{.STATE_DIR}}/.state.env
        # Set default IPFS gateway
        IPFS_GATEWAY=${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}

        # Start Aggregator
        task create-aggregator INDEX=1

        # Start aggregator service
        if [ -f infra/aggregator-1/start.sh ]; then
          IPFS_GATEWAY=${IPFS_GATEWAY} bash infra/aggregator-1/start.sh
          
          # Register service with aggregator
          if [ -n "${IPFS_URI:-}" ] && [ -n "${AGGREGATOR_URL:-}" ]; then
            wget -q --header="Content-Type: application/json" \
              --post-data="{\"uri\": \"${IPFS_URI}\"}" \
              ${AGGREGATOR_URL}/register-service -O -
          fi
        fi

        # Start Operator
        task create-operator INDEX=1

        # Start operator service
        if [ -f infra/wavs-1/start.sh ]; then
          IPFS_GATEWAY=${IPFS_GATEWAY} bash infra/wavs-1/start.sh
          
          # Wait for service to be available
          WAVS_ENDPOINT=${WAVS_ENDPOINT:-"http://127.0.0.1:8000"}
          echo "üîç Checking WAVS service at ${WAVS_ENDPOINT}..."
          
          TIMEOUT=60
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${WAVS_ENDPOINT}/app 2>/dev/null || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ WAVS service is running"
              break
            fi
            echo "‚è≥ Waiting for WAVS service... (${ELAPSED}s/${TIMEOUT}s)"
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ùå WAVS service not reachable after ${TIMEOUT}s"
            exit 1
          fi
          
          # Deploy service
          if [ -n "${IPFS_URI:-}" ]; then
            echo "üöÄ Deploying service from: ${IPFS_URI}..."
            
            if [[ "${IPFS_URI}" == http://* ]] || [[ "${IPFS_URI}" == https://* ]]; then
              # For HTTP URLs, deploy directly without IPFS gateway
              echo "üåê Using HTTP deployment"
              task wavs-cli \
                WAVS_CLI_EVM_CREDENTIAL="${DEPLOYER_PRIVATE_KEY}" \
                DEPLOYER_ADDRESS="${DEPLOYER_ADDRESS}" \
                DEPLOYER_PRIVATE_KEY="${DEPLOYER_PRIVATE_KEY}" \
                WAVS_SERVICE_MANAGER_ADDRESS="${WAVS_SERVICE_MANAGER_ADDRESS}" \
                ECDSA_STAKE_REGISTRY_ADDRESS="${ECDSA_STAKE_REGISTRY_ADDRESS}" \
                -- deploy-service --home /data --service-url ${IPFS_URI} --wavs-endpoint ${WAVS_ENDPOINT} --set-url
            elif [[ "${IPFS_URI}" == ipfs://* ]]; then
              # For IPFS URLs, use appropriate gateway
              if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
                IPFS_GATEWAY="http://127.0.0.1:8080/ipfs/"
              else
                IPFS_GATEWAY=${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}
              fi
              echo "üìÅ Using IPFS deployment"
              task wavs-cli \
                WAVS_CLI_EVM_CREDENTIAL="${DEPLOYER_PRIVATE_KEY}" \
                DEPLOYER_ADDRESS="${DEPLOYER_ADDRESS}" \
                DEPLOYER_PRIVATE_KEY="${DEPLOYER_PRIVATE_KEY}" \
                WAVS_SERVICE_MANAGER_ADDRESS="${WAVS_SERVICE_MANAGER_ADDRESS}" \
                ECDSA_STAKE_REGISTRY_ADDRESS="${ECDSA_STAKE_REGISTRY_ADDRESS}" \
                -- deploy-service --home /data --service-url ${IPFS_URI} --wavs-endpoint ${WAVS_ENDPOINT} --ipfs-gateway ${IPFS_GATEWAY} --set-url
            else
              echo "‚ùå Unsupported service URL format: ${IPFS_URI}"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No service URI found - skipping service deployment"
          fi
          
          # Register operator
          task register-operator
        fi

  register-operator:
    desc: "Register operator with middleware"
    deps: [init-environment]
    env:
      DEPLOYER_ADDRESS: '{{.DEPLOYER_ADDRESS | default ""}}'
      DEPLOYER_PRIVATE_KEY: '{{.DEPLOYER_PRIVATE_KEY | default ""}}'
      WAVS_SERVICE_MANAGER_ADDRESS: '{{.WAVS_SERVICE_MANAGER_ADDRESS | default ""}}'
      ECDSA_STAKE_REGISTRY_ADDRESS: '{{.ECDSA_STAKE_REGISTRY_ADDRESS | default ""}}'
    cmds:
      - |
        # Generate AVS signing key and capture output
        SERVICE_INDEX=0
        AVS_KEY_OUTPUT=$(task generate-avs-signing-key SERVICE_INDEX=${SERVICE_INDEX})

        # Parse the output to get the keys
        OPERATOR_PRIVATE_KEY=$(echo "$AVS_KEY_OUTPUT" | grep "OPERATOR_PRIVATE_KEY=" | cut -d'=' -f2)
        AVS_SIGNING_ADDRESS=$(echo "$AVS_KEY_OUTPUT" | grep "AVS_SIGNING_ADDRESS=" | cut -d'=' -f2)

        # Register operator with middleware
        if [ -n "${OPERATOR_PRIVATE_KEY}" ] && [ -n "${AVS_SIGNING_ADDRESS}" ] && [ -n "${WAVS_SERVICE_MANAGER_ADDRESS}" ]; then
          task wavs-middleware \
            DEPLOYER_ADDRESS="${DEPLOYER_ADDRESS}" \
            DEPLOYER_PRIVATE_KEY="${DEPLOYER_PRIVATE_KEY}" \
            WAVS_SERVICE_MANAGER_ADDRESS="${WAVS_SERVICE_MANAGER_ADDRESS}" \
            ECDSA_STAKE_REGISTRY_ADDRESS="${ECDSA_STAKE_REGISTRY_ADDRESS}" \
            -- register ${OPERATOR_PRIVATE_KEY} ${AVS_SIGNING_ADDRESS} 0.001ether
        else
          echo "Missing required variables for operator registration"
          echo "OPERATOR_PRIVATE_KEY: ${OPERATOR_PRIVATE_KEY}"
          echo "AVS_SIGNING_ADDRESS: ${AVS_SIGNING_ADDRESS}"
          echo "WAVS_SERVICE_MANAGER_ADDRESS: ${WAVS_SERVICE_MANAGER_ADDRESS}"
        fi

  generate-avs-signing-key:
    desc: "Generate AVS signing key"
    vars:
      STATE_DIR: ".docker"
      SERVICE_INDEX: '{{.SERVICE_INDEX | default "0"}}'
    cmds:
      - |
        # Generate AVS signing key
        TEMP_FILE="{{.STATE_DIR}}/tmp_avs_{{.SERVICE_INDEX}}.json"
        cast wallet new-mnemonic --json > ${TEMP_FILE}

        AVS_PRIVATE_KEY=$(jq -r '.accounts[0].private_key' ${TEMP_FILE})
        AVS_SIGNING_ADDRESS=$(jq -r '.accounts[0].address' ${TEMP_FILE})

        # For operators, we need their private key
        if [ -f infra/wavs-1/.env ]; then
          OPERATOR_PRIVATE_KEY=$(grep 'WAVS_OPERATOR_CREDENTIAL=' infra/wavs-1/.env | cut -d '=' -f2 | tr -d '"')
        fi

        rm ${TEMP_FILE}

        # Return values for caller to use (no longer stored in state)
        echo "OPERATOR_PRIVATE_KEY=${OPERATOR_PRIVATE_KEY}"
        echo "AVS_SIGNING_ADDRESS=${AVS_SIGNING_ADDRESS}"
        echo "AVS_PRIVATE_KEY=${AVS_PRIVATE_KEY}"

  # ===========================================
  # UTILITY TASKS
  # ===========================================

  lint:
    desc: "Run linting and formatting for all components"
    cmds:
      - |
        echo "Running cargo fmt on all Rust components..."
        find tools -name "Cargo.toml" -exec dirname {} \; | while read dir; do
          echo "Formatting: $dir"
          (cd "$dir" && cargo fmt 2>/dev/null || true)
        done
      - task: dos2unix

  test:
    desc: "Run tests for all components"
    cmds:
      - |
        echo "Running tests for all components..."
        find tools -name "Taskfile.yml" -exec dirname {} \; | while read dir; do
          component_name=$(basename "$dir")
          echo "Testing: $component_name"
          if grep -q "^  test:" "$dir/Taskfile.yml" 2>/dev/null; then
            (cd "$dir" && task test 2>/dev/null || echo "Tests failed for $component_name")
          else
            echo "No test task found for $component_name"
          fi
        done

  clean:
    desc: "Clean all build artifacts"
    cmds:
      - |
        echo "Cleaning build artifacts..."
        rm -rf {{.COMPONENTS_DIR}}/*.wasm 2>/dev/null || true
        find tools -name "Taskfile.yml" -exec dirname {} \; | while read dir; do
          component_name=$(basename "$dir")
          echo "Cleaning: $component_name"
          if grep -q "^  clean:" "$dir/Taskfile.yml" 2>/dev/null; then
            (cd "$dir" && task clean 2>/dev/null || true)
          fi
        done

  list-components:
    desc: "List all available components"
    cmds:
      - |
        echo "Available components:"
        find tools -name "Taskfile.yml" -exec dirname {} \; | while read dir; do
          component_name=$(basename "$dir")
          if [ -f "$dir/Taskfile.yml" ]; then
            echo "  - $component_name"
          fi
        done

  # Utility tasks

  dos2unix:
    desc: "Convert line endings to Unix format"
    cmds:
      - dos2unix ./script/* 2>/dev/null || true
      - find ./script/template -type f -exec dos2unix {} \; 2>/dev/null || true
      - find ./tools -name "script" -type d -exec find {} -type f -exec dos2unix {} \; 2>/dev/null || true

  check-prerequisites:
    desc: "Ensure all required CLI tools are installed"
    cmds:
      - |
        which cast || (echo "‚ùå 'cast' is missing. Install Foundry." && exit 1)
        which jq || (echo "‚ùå 'jq' is missing. Install it via apt/brew." && exit 1)
        which warg || (echo "‚ùå 'warg' is missing. Run: cargo binstall warg-cli" && exit 1)
        echo "‚úÖ All required tools are installed"
