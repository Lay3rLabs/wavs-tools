version: "3"

dotenv: [".env", ".docker/.state.env"]

vars:
  COMPONENTS_DIR: "./compiled"
  STATE_DIR: ".docker"

  # ===========================================
  # DOCKER IMAGE TAGS - Change these to use different versions
  # ===========================================
  WAVS_DOCKER_TAG: "35c96a4" # WAVS main image tag
  WAVS_MIDDLEWARE_DOCKER_TAG: "0.4.0-rc" # WAVS middleware image tag
  WARG_REGISTRY_DOCKER_TAG: "v0.9.3" # WARG registry image tag

  DEPLOY_ENV:
    sh: |
      if [ -f .env ] && grep -q '^DEPLOY_ENV=' .env; then
        grep '^DEPLOY_ENV=' .env | cut -d '=' -f2
      else
        echo "LOCAL"
      fi
  RPC_URL:
    sh: |
      DEPLOY_ENV="{{.DEPLOY_ENV}}"
      if [ "$DEPLOY_ENV" = "LOCAL" ]; then
        grep "^LOCAL_ETHEREUM_RPC_URL=" .env 2>/dev/null | cut -d '=' -f2 || echo "http://localhost:8545"
      elif [ "$DEPLOY_ENV" = "TESTNET" ]; then
        grep "^TESTNET_RPC_URL=" .env 2>/dev/null | cut -d '=' -f2 || echo "https://holesky.drpc.org"
      else
        echo "http://localhost:8545"
      fi

includes:
  avs_sync: ./tools/avs_sync/Taskfile.yml

tasks:
  # ===========================================
  # PUBLIC TASKS (Main user-facing commands)
  # ===========================================

  start:
    desc: "Start anvil and core services"
    deps: [init-environment]
    cmds:
      - task: start-services-background
      - task: deploy-middleware

  stop:
    desc: "Stop Anvil and Docker services"
    cmds:
      - |
        export WARG_REGISTRY_DOCKER_TAG={{.WARG_REGISTRY_DOCKER_TAG}}
        docker compose -f docker-compose.yml -f telemetry/docker-compose.yml down --remove-orphans || true
      - pkill -f "anvil --fork-url" || true

  show-versions:
    desc: "Show current Docker image versions being used"
    cmds:
      - |
        echo "üê≥ Current Docker Image Tags:"
        echo "  WAVS Main:       ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}"
        echo "  WAVS Middleware: ghcr.io/lay3rlabs/wavs-middleware:{{.WAVS_MIDDLEWARE_DOCKER_TAG}}"
        echo "  WARG Registry:   ghcr.io/reecepbcups/warg-registry:{{.WARG_REGISTRY_DOCKER_TAG}}"
        echo ""
        echo "üí° To change versions, edit the vars section at the top of Taskfile.yml"

  deploy-component:
    desc: "Deploy a component (usage: task deploy-component COMPONENT=<name>)"
    deps: [init-environment]
    cmds:
      - |
        if [ -z "{{.COMPONENT}}" ]; then
          echo "ERROR: COMPONENT parameter is required. Usage: task deploy-component COMPONENT=<name>"
          exit 1
        fi
        echo "Deploying component: {{.COMPONENT}}"
      - task: deploy-middleware
      - task: deploy-component-workflow
        vars:
          COMPONENT: "{{.COMPONENT}}"

  create-aggregator:
    desc: "Create aggregator instance (usage: task create-aggregator INDEX=<n>)"
    deps: [init-environment]
    vars:
      INDEX: "{{.INDEX | default 1}}"
    cmds:
      - task: create-aggregator-instance
        vars:
          INDEX: "{{.INDEX}}"

  create-operator:
    desc: "Create operator instance (usage: task create-operator INDEX=<n>)"
    deps: [init-environment]
    vars:
      INDEX: "{{.INDEX | default 1}}"
    cmds:
      - task: create-operator-instance
        vars:
          INDEX: "{{.INDEX}}"

  wavs-middleware:
    desc: "Run wavs middleware command"
    deps: [init-environment]
    vars:
      STATE_DIR: ".docker"
      MIDDLEWARE_DOCKER_IMAGE: "ghcr.io/lay3rlabs/wavs-middleware:{{.WAVS_MIDDLEWARE_DOCKER_TAG}}"
    cmds:
      - >
        docker run --rm --network host --env-file .env --env-file {{.STATE_DIR}}/.state.env
        -v ./.nodes:/root/.nodes {{.MIDDLEWARE_DOCKER_IMAGE}} {{.CLI_ARGS}}

  wavs-cli:
    desc: "Run wavs cli command"
    vars:
      WAVS_DOCKER_IMAGE: "ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}"
      INSTANCE: '{{.INSTANCE | default "wavs-1"}}'
    cmds:
      - |
        ENV_FILE="infra/{{.INSTANCE}}/.env"
        STATE_FILE="{{.STATE_DIR}}/.state.env"
        
        ENV_ARGS=""
        if [ -f "$ENV_FILE" ]; then
          ENV_ARGS="$ENV_ARGS --env-file $ENV_FILE"
        fi
        if [ -f "$STATE_FILE" ]; then
          ENV_ARGS="$ENV_ARGS --env-file $STATE_FILE"
        fi
        
        docker run --rm --network host \
          $ENV_ARGS \
          -w /data -v $(pwd):/data {{.WAVS_DOCKER_IMAGE}} \
          wavs-cli {{.CLI_ARGS}}

  # ===========================================
  # CORE TASKS (Setup and utilities)
  # ===========================================

  init-environment:
    desc: "Initialize environment and state files"
    cmds:
      - mkdir -p {{.STATE_DIR}}
      - |
        [ -f .env ] || cp .env.example .env
      - |
        # Always create fresh state file
        > {{.STATE_DIR}}/.state.env
      - task: update-state-from-artifacts

  update-state-from-artifacts:
    desc: "Update state from deployment artifacts"
    cmds:
      - |
        # Update state from JSON artifacts

        # Load deployer info
        if [ -f {{.STATE_DIR}}/deployer.json ]; then
          DEPLOYER_ADDRESS=$(jq -r '.accounts[0].address' {{.STATE_DIR}}/deployer.json)
          DEPLOYER_PRIVATE_KEY=$(jq -r '.accounts[0].private_key' {{.STATE_DIR}}/deployer.json)
          echo "DEPLOYER_ADDRESS=${DEPLOYER_ADDRESS}" >> {{.STATE_DIR}}/.state.env
          echo "DEPLOYER_PRIVATE_KEY=${DEPLOYER_PRIVATE_KEY}" >> {{.STATE_DIR}}/.state.env
          echo "Loaded deployer info into state"
        fi

        # Load middleware deployment info
        if [ -f .nodes/avs_deploy.json ]; then
          WAVS_SERVICE_MANAGER_ADDRESS=$(jq -r '.addresses.WavsServiceManager' .nodes/avs_deploy.json)
          ECDSA_STAKE_REGISTRY_ADDRESS=$(jq -r '.addresses.stakeRegistry' .nodes/avs_deploy.json)
          echo "WAVS_SERVICE_MANAGER_ADDRESS=${WAVS_SERVICE_MANAGER_ADDRESS}" >> {{.STATE_DIR}}/.state.env
          echo "ECDSA_STAKE_REGISTRY_ADDRESS=${ECDSA_STAKE_REGISTRY_ADDRESS}" >> {{.STATE_DIR}}/.state.env
          echo "Loaded middleware deployment info into state"
        fi

  start-services:
    desc: "Start anvil and Docker services based on DEPLOY_ENV"
    cmds:
      - |
        export WARG_REGISTRY_DOCKER_TAG={{.WARG_REGISTRY_DOCKER_TAG}}

        if [ -f .env ] && grep -q '^TESTNET_RPC_URL=' .env; then
          TESTNET_RPC_URL=$(grep -E '^TESTNET_RPC_URL=' .env | cut -d '=' -f2- | tr -d '"')
        else
          rpc_url="https://holesky.drpc.org"
          echo "No TESTNET_RPC_URL found in .env, using default ${rpc_url}"
          TESTNET_RPC_URL=${rpc_url}
        fi

        PORT=8545
        FORK_RPC_URL=${FORK_RPC_URL:-"${TESTNET_RPC_URL}"}

        if [ "{{.DEPLOY_ENV}}" = "TESTNET" ]; then
          echo "Running in testnet mode, nothing to do"
          exit 0
        fi

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          anvil --fork-url ${FORK_RPC_URL} --port ${PORT} &
          anvil_pid=$!
          trap "kill -9 $anvil_pid && echo -e '\nKilled anvil'" EXIT
          while ! cast block-number --rpc-url http://localhost:${PORT} > /dev/null 2>&1
          do
            sleep 0.25
          done

          FILES="-f docker-compose.yml -f telemetry/docker-compose.yml"
          docker compose ${FILES} pull
          docker compose ${FILES} up --force-recreate -d
          trap "docker compose ${FILES} down --remove-orphans && docker kill wavs-1 wavs-aggregator-1 > /dev/null 2>&1 && echo -e '\nKilled IPFS + Local WARG, and wavs instances'" EXIT

          echo "Started..."
          wait
        fi

  start-services-background:
    desc: "Start anvil and Docker services in background"
    cmds:
      - |
        export WARG_REGISTRY_DOCKER_TAG={{.WARG_REGISTRY_DOCKER_TAG}}

        if [ -f .env ] && grep -q '^TESTNET_RPC_URL=' .env; then
          TESTNET_RPC_URL=$(grep -E '^TESTNET_RPC_URL=' .env | cut -d '=' -f2- | tr -d '"')
        else
          rpc_url="https://holesky.drpc.org"
          echo "No TESTNET_RPC_URL found in .env, using default ${rpc_url}"
          TESTNET_RPC_URL=${rpc_url}
        fi

        PORT=8545
        FORK_RPC_URL=${FORK_RPC_URL:-"${TESTNET_RPC_URL}"}

        if [ "{{.DEPLOY_ENV}}" = "TESTNET" ]; then
          echo "Running in testnet mode, nothing to do"
          exit 0
        fi

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          # Kill any existing anvil
          pkill -f "anvil --fork-url" || true
          
          # Start anvil in background
          anvil --fork-url ${FORK_RPC_URL} --port ${PORT} &
          
          # Wait for anvil to be ready
          while ! cast block-number --rpc-url http://localhost:${PORT} > /dev/null 2>&1
          do
            sleep 0.25
          done

          FILES="-f docker-compose.yml -f telemetry/docker-compose.yml"
          docker compose ${FILES} pull
          docker compose ${FILES} up --force-recreate -d

          echo "Services started in background"
        fi

  create-deployer:
    desc: "Create and fund deployer wallet"
    deps: [init-environment]
    cmds:
      - |
        mkdir -p .docker

        # Create new deployer
        cast wallet new-mnemonic --json > .docker/deployer.json
        export DEPLOYER_PK=`jq -r .accounts[0].private_key .docker/deployer.json`
        export DEPLOYER_ADDRESS=`cast wallet address $DEPLOYER_PK`

        # Update .env file with deployer key
        if [[ "$(uname)" == *"Darwin"* ]]; then
          sed -i '' -e "s/^FUNDED_KEY=.*$/FUNDED_KEY=$DEPLOYER_PK/" .env
        else
          sed -i -e "s/^FUNDED_KEY=.*$/FUNDED_KEY=$DEPLOYER_PK/" .env
        fi

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          # Auto fund the deployer in local environment
          cast rpc anvil_setBalance "${DEPLOYER_ADDRESS}" '15000000000000000000' --rpc-url {{.RPC_URL}} > /dev/null
          BAL=`cast balance --ether $DEPLOYER_ADDRESS --rpc-url={{.RPC_URL}}`
          echo "Local deployer \`${DEPLOYER_ADDRESS}\` funded with ${BAL}ether"
        else
          # New account on testnet, must be funded externally
          echo "Fund deployer ${DEPLOYER_ADDRESS} with some ETH, or change this value in the .env"
          sleep 5
          
          while true; do
            BALANCE=`cast balance --ether $DEPLOYER_ADDRESS --rpc-url={{.RPC_URL}}`
            if [ "$BALANCE" != "0.000000000000000000" ]; then
              echo "Deployer balance is now $BALANCE"
              break
            fi
            echo "    [!] Waiting for balance to be funded by another account to this deployer..."
            sleep 5
          done
        fi
      - task: update-state-from-artifacts

  # ===========================================
  # INSTANCE CREATION (Simplified)
  # ===========================================

  create-aggregator-instance:
    desc: "Create aggregator instance"
    vars:
      INDEX: "{{.INDEX}}"
      AGG_LOC: "infra/aggregator-{{.INDEX}}"
    cmds:
      - task: generate-wallet-and-setup
        vars:
          WALLET_TYPE: "aggregator"
          INDEX: "{{.INDEX}}"
          TARGET_DIR: "{{.AGG_LOC}}"
      - |
        # Create aggregator start script
        cat > {{.AGG_LOC}}/start.sh << 'EOF'
        #!/bin/bash
        cd $(dirname "$0") || exit 1

        IMAGE=ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}
        INSTANCE=wavs-aggregator-{{.INDEX}}
        IPFS_GATEWAY=${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}

        docker kill ${INSTANCE} > /dev/null 2>&1 || true
        docker rm ${INSTANCE} > /dev/null 2>&1 || true

        docker run -d --name ${INSTANCE} --network host --stop-signal SIGKILL --env-file .env --user 1000:1000 -v .:/wavs \
          ${IMAGE} wavs-aggregator --log-level debug --host 0.0.0.0 --port 8001 --ipfs-gateway ${IPFS_GATEWAY}

        sleep 1
        EOF
        chmod +x {{.AGG_LOC}}/start.sh

  create-operator-instance:
    desc: "Create operator instance"
    vars:
      INDEX: "{{.INDEX}}"
      OP_LOC: "infra/wavs-{{.INDEX}}"
    cmds:
      - task: generate-wallet-and-setup
        vars:
          WALLET_TYPE: "operator"
          INDEX: "{{.INDEX}}"
          TARGET_DIR: "{{.OP_LOC}}"
      - |
        # Create operator start script
        cat > {{.OP_LOC}}/start.sh << 'EOF'
        #!/bin/bash
        cd $(dirname "$0") || exit 1

        IMAGE=ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}
        INSTANCE=wavs-{{.INDEX}}
        IPFS_GATEWAY=${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}

        docker kill ${INSTANCE} > /dev/null 2>&1 || true
        docker rm ${INSTANCE} > /dev/null 2>&1 || true

        docker run -d --name ${INSTANCE} --network host --env-file .env -v .:/root/wavs \
          ${IMAGE} wavs --home /root/wavs --ipfs-gateway ${IPFS_GATEWAY} --host 0.0.0.0 --log-level info

        sleep 1
        EOF
        chmod +x {{.OP_LOC}}/start.sh

  generate-wallet-and-setup:
    desc: "Generate wallet and setup instance directory"
    vars:
      WALLET_TYPE: "{{.WALLET_TYPE}}"
      INDEX: "{{.INDEX}}"
      TARGET_DIR: "{{.TARGET_DIR}}"
    cmds:
      - mkdir -p {{.TARGET_DIR}}
      - |
        # Generate wallet
        TEMP_FILE="{{.STATE_DIR}}/tmp_{{.WALLET_TYPE}}_{{.INDEX}}.json"
        cast wallet new-mnemonic --json > $TEMP_FILE
        MNEMONIC=$(jq -r .mnemonic $TEMP_FILE)
        PRIVATE_KEY=$(jq -r .accounts[0].private_key $TEMP_FILE)
        ADDRESS=$(cast wallet address "$PRIVATE_KEY")
        rm $TEMP_FILE

        # Create .env file
        if [ "{{.WALLET_TYPE}}" = "aggregator" ]; then
          cat > {{.TARGET_DIR}}/.env << EOF
        # Mnemonic for reference: ${MNEMONIC}
        WAVS_AGGREGATOR_DATA=~/wavs/aggregator
        WAVS_AGGREGATOR_CREDENTIAL="${PRIVATE_KEY}"
        WAVS_AGGREGATOR_HD_INDEX=0
        EOF
        else
          cat > {{.TARGET_DIR}}/.env << EOF
        WAVS_SUBMISSION_MNEMONIC="${MNEMONIC}"
        WAVS_CLI_EVM_CREDENTIAL="${PRIVATE_KEY}"
        EOF
        fi

        # Copy config files
        cp wavs.toml {{.TARGET_DIR}}/wavs.toml

        # Fund wallet if local
        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          cast rpc anvil_setBalance ${ADDRESS} '15000000000000000000' --rpc-url {{.RPC_URL}} > /dev/null
          BAL=$(cast balance --ether ${ADDRESS} --rpc-url={{.RPC_URL}})
          echo "Local {{.WALLET_TYPE}} ${ADDRESS} funded with ${BAL}ether"
        else
          echo "Fund {{.WALLET_TYPE}} ${ADDRESS} with some ETH"
        fi

  # ===========================================
  # DEPLOYMENT WORKFLOW
  # ===========================================

  deploy-middleware:
    desc: "Deploy WAVS middleware contracts"
    deps: [create-deployer]
    cmds:
      - |
        echo "Deploying WAVS middleware..."
      - task: wavs-middleware
        vars:
          CLI_ARGS: "deploy"
      - task: update-state-from-artifacts
      - |
        echo "‚úì Middleware deployed successfully"

  deploy-component-workflow:
    desc: "Complete component deployment workflow"
    vars:
      COMPONENT: "{{.COMPONENT}}"
    cmds:
      - |
        if [ ! -d "tools/{{.COMPONENT}}" ]; then
          echo "‚ùå Component {{.COMPONENT}} not found in tools/"
          exit 1
        fi

        echo "üöÄ Deploying component: {{.COMPONENT}}"

        # 1. Build WASM component
        echo "üì¶ Building WASM component..."
        task build-components COMPONENT={{.COMPONENT}}

        # 2. Deploy component contracts
        echo "üìÑ Deploying component contracts..."
        cd tools/{{.COMPONENT}} && task deploy-contracts && cd ../..

        # 3. Upload to WASI registry
        echo "üì§ Uploading to WASI registry..."
        task upload-component-to-registry COMPONENT={{.COMPONENT}}

        # 4. Build service configuration
        echo "‚öôÔ∏è Building service configuration..."
        (cd tools/{{.COMPONENT}} && task build-service) || true

        # 5. Upload to IPFS
        echo "‚òÅÔ∏è Uploading service to IPFS..."
        SERVICE_FILE=.docker/service.json task upload-to-ipfs

        # 6. Start services
        echo "üîÑ Starting aggregator and operator..."
        task start-aggregator-and-operator

        echo "‚úÖ Component {{.COMPONENT}} deployed successfully!"

  upload-component-to-registry:
    desc: "Upload component to WASI registry"
    vars:
      COMPONENT: "{{.COMPONENT}}"
    cmds:
      - |
        PKG_NAMESPACE=$(grep "PKG_NAMESPACE:" tools/{{.COMPONENT}}/Taskfile.yml | head -1 | sed 's/.*PKG_NAMESPACE: *"\([^"]*\)".*/\1/')
        PKG_NAME=$(grep "PKG_NAME:" tools/{{.COMPONENT}}/Taskfile.yml | head -1 | sed 's/.*PKG_NAME: *\([^ ]*\).*/\1/')
        PKG_VERSION=$(grep "PKG_VERSION:" tools/{{.COMPONENT}}/Taskfile.yml | head -1 | sed 's/.*PKG_VERSION: *\([^ ]*\).*/\1/')

        echo "Package: ${PKG_NAMESPACE}:${PKG_NAME}@${PKG_VERSION}"
        PKG_NAMESPACE=${PKG_NAMESPACE} PKG_NAME=${PKG_NAME} PKG_VERSION=${PKG_VERSION} COMPONENT_FILENAME={{.COMPONENT}}.wasm task upload-to-wasi-registry

  upload-to-ipfs:
    desc: Upload a service file to IPFS and return the CID
    cmds:
      - |
        if [ -z "$SERVICE_FILE" ] || [ ! -f "$SERVICE_FILE" ]; then
          echo "‚ùå SERVICE_FILE not set or does not exist: '$SERVICE_FILE'"
          exit 1
        fi

        DEPLOY_ENV=$(grep "^DEPLOY_ENV=" .env | cut -d '=' -f2 | tr '[:lower:]' '[:upper:]')
        echo "üìÑ SERVICE_FILE: $SERVICE_FILE"
        echo "üåç DEPLOY_ENV: $DEPLOY_ENV"

        if [ "$DEPLOY_ENV" = "LOCAL" ]; then
          ipfs_cid=$(ipfs add -Q "$SERVICE_FILE")
        elif [ "$DEPLOY_ENV" = "TESTNET" ]; then
          if [ -z "$PINATA_API_KEY" ]; then
            echo "‚ùå PINATA_API_KEY not set"
            exit 1
          fi
          ipfs_cid=$(curl -s -X POST https://api.pinata.cloud/pinning/pinFileToIPFS \
            -H "Authorization: Bearer $PINATA_API_KEY" \
            -F "file=@${SERVICE_FILE}" | jq -r '.IpfsHash')
        else
          echo "‚ùå Unknown DEPLOY_ENV: $DEPLOY_ENV"
          exit 1
        fi

        echo "‚úÖ Uploaded to IPFS: $ipfs_cid"
        echo "$ipfs_cid"

  build-components:
    desc: "Build all or specific WASM components"
    cmds:
      - |
        COMPONENT="{{.COMPONENT}}"
        if [ -n "$COMPONENT" ]; then
          echo "Building specific component: $COMPONENT"
          if [ -d "tools/$COMPONENT" ]; then
            cd tools/$COMPONENT && task wasi-build && cd ../..
          else
            echo "‚ùå Component $COMPONENT not found in tools/"
            exit 1
          fi
        else
          echo "Building all components..."
          # Build all components with Taskfiles
          RECIPE="wasi-build"
          TASKFILE_DIRS=$(find tools/* -maxdepth 1 -name "Taskfile.yml" 2>/dev/null || true)
          
          if [ -z "$TASKFILE_DIRS" ]; then
            echo "No Taskfile.yml found in tools/*"
            exit 0
          fi
          
          for taskfile_path in $TASKFILE_DIRS; do
            if grep -q "^  ${RECIPE}:" "$taskfile_path" 2>/dev/null; then
              parent_dir=$(dirname "$taskfile_path")
              component_name=$(basename "$parent_dir")
              echo "Building component: $component_name"
              (cd "$parent_dir" && task $RECIPE)
            else
              parent_dir=$(dirname "$taskfile_path")
              component_name=$(basename "$parent_dir")
              echo "Recipe '$RECIPE' not found in $component_name/Taskfile.yml"
            fi
          done
          
          echo "Component build complete"
        fi

  upload-to-wasi-registry:
    desc: "Upload component to WASI registry"
    deps: [init-environment]
    cmds:
      - |
        # Get registry based on DEPLOY_ENV
        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          REGISTRY=localhost:8090
        elif [ "{{.DEPLOY_ENV}}" = "TESTNET" ]; then
          REGISTRY=wa.dev
        else
          echo "Unknown DEPLOY_ENV: {{.DEPLOY_ENV}}"
          exit 1
        fi
        export REGISTRY
        if [ -z "$REGISTRY" ]; then
            echo "‚ùå REGISTRY is not set."
            exit 1
        fi

        # Get PKG_NAMESPACE based on DEPLOY_ENV
        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          export PKG_NAMESPACE="example"
        else
          read -p "Enter the PKG_NAMESPACE for ${REGISTRY}: " namespace
          export PKG_NAMESPACE="${namespace}"
        fi
        if [ -z "$PKG_NAMESPACE" ]; then
            echo "‚ùå PKG_NAMESPACE is not set."
            exit 1
        fi

        # Validate required environment variables
        for var in PKG_NAME PKG_VERSION COMPONENT_FILENAME; do
          if [ -z "${!var}" ]; then
            echo "‚ùå ERROR: $var environment variable is required"
            exit 1
          fi
        done

        COMPONENT_PATH="{{.COMPONENTS_DIR}}/${COMPONENT_FILENAME}"
        if [ ! -f "$COMPONENT_PATH" ]; then
          echo "‚ùå Component file not found: $COMPONENT_PATH"
          exit 1
        fi

        # Determine protocol
        PROTOCOL="https"
        if [[ "$REGISTRY" == *"localhost"* ]] || [[ "$REGISTRY" == *"127.0.0.1"* ]]; then
            PROTOCOL="http"
        fi

        PACKAGE_NAME="${PKG_NAMESPACE}:${PKG_NAME}"
        echo "üì§ Uploading: $COMPONENT_PATH"
        echo "   To: ${PROTOCOL}://${REGISTRY}/${PACKAGE_NAME}@${PKG_VERSION}"

        # Upload with proper error handling
        set +e  # Don't exit on error
        output=$(warg publish release --registry ${PROTOCOL}://${REGISTRY} --name ${PKG_NAMESPACE}:${PKG_NAME} --version ${PKG_VERSION} ${COMPONENT_PATH} 2>&1)
        exit_code=$?
        warg reset --registry ${PROTOCOL}://${REGISTRY}

        # Check for specific error conditions in the output
        if [[ $exit_code -ne 0 ]]; then
            if [[ "$output" =~ "failed to prove inclusion" ]]; then
                echo "‚úÖ Package uploaded to local registry successfully..."
                echo "   (This is expected for local registries)"
            elif [[ "$output" =~ "error sending request for url" ]]; then
                echo "‚ö†Ô∏è Registry not available - check that you are running the registry locally"
                echo "${output}"
            else
                echo "‚ö†Ô∏è Upload error: ${output}"
            fi
        else
            echo "‚úÖ Package uploaded successfully"
        fi
        set -e  # Re-enable exit on error

        # Store registry info in state for service configuration
        {
          echo "REGISTRY=${REGISTRY}"
          echo "PKG_NAMESPACE=${PKG_NAMESPACE}"
          echo "PKG_NAME=${PKG_NAME}"
          echo "PKG_VERSION=${PKG_VERSION}"
        } >> {{.STATE_DIR}}/.state.env

  start-aggregator-and-operator:
    desc: "Start aggregator and operator services"
    deps: [init-environment]
    cmds:
      - |
        # Set default IPFS gateway
        IPFS_GATEWAY=${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}

        # Start Aggregator
        task create-aggregator INDEX=1

        # Start aggregator service
        if [ -f infra/aggregator-1/start.sh ]; then
          IPFS_GATEWAY=${IPFS_GATEWAY} bash infra/aggregator-1/start.sh
          
          # Register service with aggregator
          if [ -n "${IPFS_URI:-}" ] && [ -n "${AGGREGATOR_URL:-}" ]; then
            wget -q --header="Content-Type: application/json" \
              --post-data="{\"uri\": \"${IPFS_URI}\"}" \
              ${AGGREGATOR_URL}/register-service -O -
          fi
        fi

        # Start Operator
        task create-operator INDEX=1

        # Start operator service
        if [ -f infra/wavs-1/start.sh ]; then
          IPFS_GATEWAY=${IPFS_GATEWAY} bash infra/wavs-1/start.sh
          
          # Wait for service to be available
          WAVS_ENDPOINT=${WAVS_ENDPOINT:-"http://127.0.0.1:8000"}
          echo "üîç Checking WAVS service at ${WAVS_ENDPOINT}..."
          
          TIMEOUT=60
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${WAVS_ENDPOINT}/app 2>/dev/null || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ WAVS service is running"
              break
            fi
            echo "‚è≥ Waiting for WAVS service... (${ELAPSED}s/${TIMEOUT}s)"
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ùå WAVS service not reachable after ${TIMEOUT}s"
            exit 1
          fi
          
          # Deploy service
          if [ -n "${IPFS_URI:-}" ]; then
            echo "üöÄ Deploying service from: ${IPFS_URI}..."
            
            if [[ "${IPFS_URI}" == http://* ]] || [[ "${IPFS_URI}" == https://* ]]; then
              # For HTTP URLs, deploy directly without IPFS gateway
              echo "üåê Using HTTP deployment"
              task wavs-cli -- deploy-service --service-url ${IPFS_URI} --wavs-endpoint ${WAVS_ENDPOINT} --set-url
            elif [[ "${IPFS_URI}" == ipfs://* ]]; then
              # For IPFS URLs, use appropriate gateway
              if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
                IPFS_GATEWAY="http://127.0.0.1:8080/ipfs/"
              else
                IPFS_GATEWAY=${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}
              fi
              echo "üìÅ Using IPFS deployment"
              task wavs-cli -- deploy-service --service-url ${IPFS_URI} --wavs-endpoint ${WAVS_ENDPOINT} --ipfs-gateway ${IPFS_GATEWAY} --set-url
            else
              echo "‚ùå Unsupported service URL format: ${IPFS_URI}"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No service URI found - skipping service deployment"
          fi
          
          # Register operator
          task register-operator
        fi

  register-operator:
    desc: "Register operator with middleware"
    deps: [init-environment]
    vars:
      STATE_DIR: ".docker"
    cmds:
      - |
        # Generate AVS signing key
        SERVICE_INDEX=0
        task generate-avs-signing-key SERVICE_INDEX=${SERVICE_INDEX}

        # Register operator with middleware
        [ -f {{.STATE_DIR}}/.state.env ] && source {{.STATE_DIR}}/.state.env
        if [ -n "${OPERATOR_PRIVATE_KEY:-}" ] && [ -n "${AVS_SIGNING_ADDRESS:-}" ] && [ -n "${WAVS_SERVICE_MANAGER_ADDRESS:-}" ]; then
          task wavs-middleware -- register ${OPERATOR_PRIVATE_KEY} ${AVS_SIGNING_ADDRESS} 0.001ether
        else
          echo "Missing required variables for operator registration"
        fi

  generate-avs-signing-key:
    desc: "Generate AVS signing key"
    vars:
      STATE_DIR: ".docker"
      SERVICE_INDEX: '{{.SERVICE_INDEX | default "0"}}'
    cmds:
      - |
        # Generate AVS signing key
        TEMP_FILE="{{.STATE_DIR}}/tmp_avs_{{.SERVICE_INDEX}}.json"
        cast wallet new-mnemonic --json > ${TEMP_FILE}

        AVS_PRIVATE_KEY=$(jq -r '.accounts[0].private_key' ${TEMP_FILE})
        AVS_SIGNING_ADDRESS=$(jq -r '.accounts[0].address' ${TEMP_FILE})

        # For operators, we need their private key
        if [ -f infra/wavs-1/.env ]; then
          OPERATOR_PRIVATE_KEY=$(grep 'WAVS_OPERATOR_CREDENTIAL=' infra/wavs-1/.env | cut -d '=' -f2 | tr -d '"')
        fi

        rm ${TEMP_FILE}

        # Store in state
        echo "OPERATOR_PRIVATE_KEY=${OPERATOR_PRIVATE_KEY}" >> {{.STATE_DIR}}/.state.env
        echo "AVS_SIGNING_ADDRESS=${AVS_SIGNING_ADDRESS}" >> {{.STATE_DIR}}/.state.env
        echo "AVS_PRIVATE_KEY=${AVS_PRIVATE_KEY}" >> {{.STATE_DIR}}/.state.env

  # ===========================================
  # UTILITY TASKS
  # ===========================================

  lint:
    desc: "Run linting and formatting for all components"
    cmds:
      - |
        echo "Running cargo fmt on all Rust components..."
        find tools -name "Cargo.toml" -exec dirname {} \; | while read dir; do
          echo "Formatting: $dir"
          (cd "$dir" && cargo fmt 2>/dev/null || true)
        done
      - task: dos2unix

  test:
    desc: "Run tests for all components"
    cmds:
      - |
        echo "Running tests for all components..."
        find tools -name "Taskfile.yml" -exec dirname {} \; | while read dir; do
          component_name=$(basename "$dir")
          echo "Testing: $component_name"
          if grep -q "^  test:" "$dir/Taskfile.yml" 2>/dev/null; then
            (cd "$dir" && task test 2>/dev/null || echo "Tests failed for $component_name")
          else
            echo "No test task found for $component_name"
          fi
        done

  clean:
    desc: "Clean all build artifacts"
    cmds:
      - |
        echo "Cleaning build artifacts..."
        rm -rf {{.COMPONENTS_DIR}}/*.wasm 2>/dev/null || true
        find tools -name "Taskfile.yml" -exec dirname {} \; | while read dir; do
          component_name=$(basename "$dir")
          echo "Cleaning: $component_name"
          if grep -q "^  clean:" "$dir/Taskfile.yml" 2>/dev/null; then
            (cd "$dir" && task clean 2>/dev/null || true)
          fi
        done

  list-components:
    desc: "List all available components"
    cmds:
      - |
        echo "Available components:"
        find tools -name "Taskfile.yml" -exec dirname {} \; | while read dir; do
          component_name=$(basename "$dir")
          if [ -f "$dir/Taskfile.yml" ]; then
            echo "  - $component_name"
          fi
        done

  # Utility tasks
  get-rpc-url:
    desc: "Get RPC URL based on DEPLOY_ENV"
    silent: true
    cmds:
      - |
        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          if [ -f .env ] && grep -q '^LOCAL_ETHEREUM_RPC_URL=' .env; then
            grep '^LOCAL_ETHEREUM_RPC_URL=' .env | cut -d '=' -f2
          else
            echo "http://localhost:8545"
          fi
        elif [ "{{.DEPLOY_ENV}}" = "TESTNET" ]; then
          if [ -f .env ] && grep -q '^TESTNET_RPC_URL=' .env; then
            grep '^TESTNET_RPC_URL=' .env | cut -d '=' -f2
          else
            echo "https://holesky.drpc.org"
          fi
        else
          echo "http://localhost:8545"
        fi

  dos2unix:
    desc: "Convert line endings to Unix format"
    cmds:
      - dos2unix ./script/* 2>/dev/null || true
      - find ./script/template -type f -exec dos2unix {} \; 2>/dev/null || true
      - find ./tools -name "script" -type d -exec find {} -type f -exec dos2unix {} \; 2>/dev/null || true
