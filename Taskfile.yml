version: "3"

dotenv: [".env", ".docker/.state.env"]

vars:
  COMPONENTS_DIR: "./compiled"
  STATE_DIR: ".docker"

  # ===========================================
  # DOCKER IMAGE TAGS - Change these to use different versions
  # ===========================================
  WAVS_DOCKER_TAG: "35c96a4" # WAVS main image tag
  WAVS_MIDDLEWARE_DOCKER_TAG: "0.4.0-rc" # WAVS middleware image tag
  WARG_REGISTRY_DOCKER_TAG: "v0.9.3" # WARG registry image tag

  # Default environment settings (can be overridden with env vars)
  DEPLOY_ENV: '{{.DEPLOY_ENV | default "LOCAL"}}'
  RPC_URL: '{{.RPC_URL | default "http://localhost:8545"}}'

includes:
  avs_sync: ./tools/avs_sync/Taskfile.yml

tasks:
  # ===========================================
  # PUBLIC TASKS (Main user-facing commands)
  # ===========================================

  start:
    desc: "Start anvil and core services"
    deps: [check-prerequisites]
    cmds:
      - task: start-services-background
      - task: deploy-middleware

  stop:
    desc: "Stop Anvil and Docker services"
    env:
      WARG_REGISTRY_DOCKER_TAG: "{{.WARG_REGISTRY_DOCKER_TAG}}"
    cmds:
      - docker compose -f docker-compose.yml -f telemetry/docker-compose.yml down --remove-orphans || true
      - pkill -f "anvil --fork-url" || true
      - warg reset

  restart:
    desc: "Restart Anvil and Docker services"
    cmds:
      - task stop
      - task start

  create-aggregator:
    desc: "Create aggregator instance (usage: task create-aggregator INDEX=<n>)"
    vars:
      INDEX: "{{.INDEX | default 1}}"
    cmds:
      - task: create-aggregator-instance
        vars:
          INDEX: "{{.INDEX}}"

  create-operator:
    desc: "Create operator instance (usage: task create-operator INDEX=<n>)"
    vars:
      INDEX: "{{.INDEX | default 1}}"
    cmds:
      - task: create-operator-instance
        vars:
          INDEX: "{{.INDEX}}"

  wavs-middleware:
    desc: "Run wavs middleware command"
    deps: [init-env]
    vars:
      MIDDLEWARE_DOCKER_IMAGE: "ghcr.io/lay3rlabs/wavs-middleware:{{.WAVS_MIDDLEWARE_DOCKER_TAG}}"
      WAVS_SERVICE_MANAGER_ADDRESS: '{{.WAVS_SERVICE_MANAGER_ADDRESS | default ""}}'
    env:
      LST_CONTRACT_ADDRESS: '{{.LST_CONTRACT_ADDRESS | default ""}}'
      LST_STRATEGY_ADDRESS: '{{.LST_STRATEGY_ADDRESS | default ""}}'
    cmds:
      - |
        docker run --rm --network host \
          --env-file .env \
          -e WAVS_SERVICE_MANAGER_ADDRESS={{.WAVS_SERVICE_MANAGER_ADDRESS}} \
          -v ./.nodes:/root/.nodes {{.MIDDLEWARE_DOCKER_IMAGE}} {{.CLI_ARGS}}

  wavs-cli:
    desc: "Run wavs cli command"
    vars:
      WAVS_DOCKER_IMAGE: "ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}"
      INSTANCE: '{{.INSTANCE | default "wavs-1"}}'
      CLI_ARGS: '{{.CLI_ARGS | default ""}}'
    cmds:
      - |
        INSTANCE="{{.INSTANCE}}"

        # Check if instance env file exists
        if [ -f "infra/${INSTANCE}/.env" ]; then
          ENV_FILE_ARG="--env-file infra/${INSTANCE}/.env"
        else
          ENV_FILE_ARG="--env-file .env"
        fi

        docker run --rm --network host \
          $ENV_FILE_ARG \
          -w /data -v $(pwd):/data {{.WAVS_DOCKER_IMAGE}} \
          wavs-cli {{.CLI_ARGS}}

  # ===========================================
  # CORE TASKS (Setup and utilities)
  # ===========================================

  init-env:
    desc: "Initialize environment and state files (run once before middleware deployment)"
    cmds:
      - mkdir -p {{.STATE_DIR}}
      - |
        [ -f .env ] || cp .env.example .env
      - |
        # Always create fresh state file
        > {{.STATE_DIR}}/.state.env
      - task: update-state-from-artifacts

  update-state-from-artifacts:
    desc: "Update state from deployment artifacts"
    cmds:
      - |
        # Update state from JSON artifacts

        # Load deployer info
        if [ -f {{.STATE_DIR}}/deployer.json ]; then
          DEPLOYER_ADDRESS=$(jq -r '.accounts[0].address' {{.STATE_DIR}}/deployer.json)
          DEPLOYER_PRIVATE_KEY=$(jq -r '.accounts[0].private_key' {{.STATE_DIR}}/deployer.json)
          echo "DEPLOYER_ADDRESS=${DEPLOYER_ADDRESS}" >> {{.STATE_DIR}}/.state.env
          echo "DEPLOYER_PRIVATE_KEY=${DEPLOYER_PRIVATE_KEY}" >> {{.STATE_DIR}}/.state.env
          echo "Loaded deployer info into state"
        fi

        # Load middleware deployment info
        if [ -f .nodes/avs_deploy.json ]; then
          WAVS_SERVICE_MANAGER_ADDRESS=$(jq -r '.addresses.WavsServiceManager' .nodes/avs_deploy.json)
          ECDSA_STAKE_REGISTRY_ADDRESS=$(jq -r '.addresses.stakeRegistry' .nodes/avs_deploy.json)
          echo "WAVS_SERVICE_MANAGER_ADDRESS=${WAVS_SERVICE_MANAGER_ADDRESS}" >> {{.STATE_DIR}}/.state.env
          echo "ECDSA_STAKE_REGISTRY_ADDRESS=${ECDSA_STAKE_REGISTRY_ADDRESS}" >> {{.STATE_DIR}}/.state.env
          echo "Loaded middleware deployment info into state"
        fi

  start-services:
    desc: "Start anvil and Docker services based on DEPLOY_ENV"
    cmds:
      - |
        export WARG_REGISTRY_DOCKER_TAG={{.WARG_REGISTRY_DOCKER_TAG}}

        if [ -f .env ] && grep -q '^TESTNET_RPC_URL=' .env; then
          TESTNET_RPC_URL=$(grep -E '^TESTNET_RPC_URL=' .env | cut -d '=' -f2- | tr -d '"')
        else
          rpc_url="https://holesky.drpc.org"
          echo "No TESTNET_RPC_URL found in .env, using default ${rpc_url}"
          TESTNET_RPC_URL=${rpc_url}
        fi

        PORT=8545
        FORK_RPC_URL=${FORK_RPC_URL:-"${TESTNET_RPC_URL}"}

        if [ "{{.DEPLOY_ENV}}" = "TESTNET" ]; then
          echo "Running in testnet mode, nothing to do"
          exit 0
        fi

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          anvil --fork-url ${FORK_RPC_URL} --port ${PORT} &
          anvil_pid=$!
          trap "kill -9 $anvil_pid && echo -e '\nKilled anvil'" EXIT
          while ! cast block-number --rpc-url http://localhost:${PORT} > /dev/null 2>&1
          do
            sleep 0.25
          done

          FILES="-f docker-compose.yml -f telemetry/docker-compose.yml"
          docker compose ${FILES} pull
          docker compose ${FILES} up --force-recreate -d
          trap "docker compose ${FILES} down --remove-orphans && docker kill wavs-1 wavs-aggregator-1 > /dev/null 2>&1 && echo -e '\nKilled IPFS + Local WARG, and wavs instances'" EXIT

          echo "Started..."
          wait
        fi

  start-services-background:
    desc: "Start anvil and Docker services in background"
    cmds:
      - |
        export WARG_REGISTRY_DOCKER_TAG={{.WARG_REGISTRY_DOCKER_TAG}}

        if [ -f .env ] && grep -q '^TESTNET_RPC_URL=' .env; then
          TESTNET_RPC_URL=$(grep -E '^TESTNET_RPC_URL=' .env | cut -d '=' -f2- | tr -d '"')
        else
          rpc_url="https://holesky.drpc.org"
          echo "No TESTNET_RPC_URL found in .env, using default ${rpc_url}"
          TESTNET_RPC_URL=${rpc_url}
        fi

        PORT=8545
        FORK_RPC_URL=${FORK_RPC_URL:-"${TESTNET_RPC_URL}"}

        if [ "{{.DEPLOY_ENV}}" = "TESTNET" ]; then
          echo "Running in testnet mode, nothing to do"
          exit 0
        fi

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          # Kill any existing anvil
          pkill -f "anvil --fork-url" || true
          
          # Start anvil in background
          anvil --fork-url ${FORK_RPC_URL} --port ${PORT} &
          
          # Wait for anvil to be ready
          while ! cast block-number --rpc-url http://localhost:${PORT} > /dev/null 2>&1
          do
            sleep 0.25
          done

          FILES="-f docker-compose.yml -f telemetry/docker-compose.yml"
          docker compose ${FILES} pull
          docker compose ${FILES} up --force-recreate -d

          echo "Services started in background"
        fi

  create-deployer:
    desc: "Create and fund deployer wallet"
    cmds:
      - |
        mkdir -p .docker

        # Create new deployer
        cast wallet new-mnemonic --json > .docker/deployer.json
        export DEPLOYER_PK=`jq -r .accounts[0].private_key .docker/deployer.json`
        export DEPLOYER_ADDRESS=`cast wallet address $DEPLOYER_PK`

        # Update .env file with deployer key
        if [[ "$(uname)" == *"Darwin"* ]]; then
          sed -i '' -e "s/^FUNDED_KEY=.*$/FUNDED_KEY=$DEPLOYER_PK/" .env
        else
          sed -i -e "s/^FUNDED_KEY=.*$/FUNDED_KEY=$DEPLOYER_PK/" .env
        fi

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          # Auto fund the deployer in local environment
          cast rpc anvil_setBalance "${DEPLOYER_ADDRESS}" '15000000000000000000' --rpc-url {{.RPC_URL}} > /dev/null
          BAL=`cast balance --ether $DEPLOYER_ADDRESS --rpc-url={{.RPC_URL}}`
          echo "Local deployer \`${DEPLOYER_ADDRESS}\` funded with ${BAL}ether"
        else
          # New account on testnet, must be funded externally
          echo "Fund deployer ${DEPLOYER_ADDRESS} with some ETH, or change this value in the .env"
          sleep 5
          
          while true; do
            BALANCE=`cast balance --ether $DEPLOYER_ADDRESS --rpc-url={{.RPC_URL}}`
            if [ "$BALANCE" != "0.000000000000000000" ]; then
              echo "Deployer balance is now $BALANCE"
              break
            fi
            echo "    [!] Waiting for balance to be funded by another account to this deployer..."
            sleep 5
          done
        fi
      - task: update-state-from-artifacts

  # ===========================================
  # INSTANCE CREATION (Simplified)
  # ===========================================

  create-aggregator-instance:
    desc: "Create aggregator instance"
    vars:
      INDEX: "{{.INDEX}}"
      AGG_LOC: "infra/aggregator-{{.INDEX}}"
    cmds:
      - task: generate-wallet-and-setup
        vars:
          WALLET_TYPE: "aggregator"
          INDEX: "{{.INDEX}}"
          TARGET_DIR: "{{.AGG_LOC}}"
      - |
        # Create aggregator start script
        cat > {{.AGG_LOC}}/start.sh << 'EOF'
        #!/bin/bash
        cd $(dirname "$0") || exit 1

        IMAGE=ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}
        INSTANCE=wavs-aggregator-{{.INDEX}}
        IPFS_GATEWAY=${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}

        docker kill ${INSTANCE} > /dev/null 2>&1 || true
        docker rm ${INSTANCE} > /dev/null 2>&1 || true

        docker run -d --name ${INSTANCE} --network host --stop-signal SIGKILL --env-file .env --user 1000:1000 -v .:/wavs \
          ${IMAGE} wavs-aggregator --log-level debug --host 0.0.0.0 --port 8001 --ipfs-gateway ${IPFS_GATEWAY}

        sleep 1
        EOF
        chmod +x {{.AGG_LOC}}/start.sh

  create-operator-instance:
    desc: "Create operator instance"
    vars:
      INDEX: "{{.INDEX}}"
      OP_LOC: "infra/wavs-{{.INDEX}}"
    cmds:
      - task: generate-wallet-and-setup
        vars:
          WALLET_TYPE: "operator"
          INDEX: "{{.INDEX}}"
          TARGET_DIR: "{{.OP_LOC}}"
      - |
        # Create operator start script
        cat > {{.OP_LOC}}/start.sh << 'EOF'
        #!/bin/bash
        cd $(dirname "$0") || exit 1

        IMAGE=ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG}}
        INSTANCE=wavs-{{.INDEX}}
        IPFS_GATEWAY=${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}

        docker kill ${INSTANCE} > /dev/null 2>&1 || true
        docker rm ${INSTANCE} > /dev/null 2>&1 || true

        docker run -d --name ${INSTANCE} --network host --env-file .env -v .:/root/wavs \
          ${IMAGE} wavs --home /root/wavs --ipfs-gateway ${IPFS_GATEWAY} --host 0.0.0.0 --log-level info

        sleep 1
        EOF
        chmod +x {{.OP_LOC}}/start.sh

  generate-wallet-and-setup:
    desc: "Generate wallet and setup instance directory"
    vars:
      WALLET_TYPE: "{{.WALLET_TYPE}}"
      INDEX: "{{.INDEX}}"
      TARGET_DIR: "{{.TARGET_DIR}}"
    cmds:
      - mkdir -p {{.TARGET_DIR}}
      - |
        # Create .env file
        if [ "{{.WALLET_TYPE}}" = "aggregator" ]; then
          # Generate wallet for aggregator
          TEMP_FILE="{{.STATE_DIR}}/tmp_{{.WALLET_TYPE}}_{{.INDEX}}.json"
          cast wallet new-mnemonic --json > $TEMP_FILE
          MNEMONIC=$(jq -r .mnemonic $TEMP_FILE)
          PRIVATE_KEY=$(jq -r .accounts[0].private_key $TEMP_FILE)
          ADDRESS=$(cast wallet address "$PRIVATE_KEY")
          rm $TEMP_FILE
          
          cat > {{.TARGET_DIR}}/.env << EOF
        # Mnemonic for reference: ${MNEMONIC}
        WAVS_AGGREGATOR_DATA=~/wavs/aggregator
        WAVS_AGGREGATOR_CREDENTIAL="${PRIVATE_KEY}"
        WAVS_AGGREGATOR_HD_INDEX=0
        EOF
        else
          # Use deployer key for operator to ensure contract ownership consistency
          source {{.STATE_DIR}}/.state.env
          # Get the mnemonic from the deployer.json file
          DEPLOYER_MNEMONIC=$(jq -r .mnemonic {{.STATE_DIR}}/deployer.json)
          ADDRESS="${DEPLOYER_ADDRESS}"
          
          cat > {{.TARGET_DIR}}/.env << EOF
        WAVS_SUBMISSION_MNEMONIC="${DEPLOYER_MNEMONIC}"
        WAVS_CLI_EVM_CREDENTIAL="${DEPLOYER_PRIVATE_KEY}"
        EOF
        fi

        # Copy config files
        cp wavs.toml {{.TARGET_DIR}}/wavs.toml

        # Fund wallet if local
        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          cast rpc anvil_setBalance ${ADDRESS} '15000000000000000000' --rpc-url {{.RPC_URL}} > /dev/null
          BAL=$(cast balance --ether ${ADDRESS} --rpc-url={{.RPC_URL}})
          echo "Local {{.WALLET_TYPE}} ${ADDRESS} funded with ${BAL}ether"
        else
          echo "Fund {{.WALLET_TYPE}} ${ADDRESS} with some ETH"
        fi

  # ===========================================
  # DEPLOYMENT WORKFLOW
  # ===========================================

  deploy-middleware:
    desc: "Deploy WAVS middleware contracts"
    deps: [create-deployer]
    cmds:
      - |
        echo "Deploying WAVS middleware..."
      - task: wavs-middleware
        vars:
          CLI_ARGS: "deploy"
      - task: update-state-from-artifacts
      - |
        echo "‚úì Middleware deployed successfully"

  upload-to-ipfs:
    desc: Upload a service file to IPFS and return the CID
    vars:
      SERVICE_FILE: '{{.SERVICE_FILE | default ".docker/service.json"}}'
    env:
      PINATA_API_KEY: '{{.PINATA_API_KEY | default ""}}'
    cmds:
      - |
        SERVICE_FILE="{{.SERVICE_FILE}}"
        if [ -z "$SERVICE_FILE" ] || [ ! -f "$SERVICE_FILE" ]; then
          echo "‚ùå SERVICE_FILE not set or does not exist: '$SERVICE_FILE'"
          exit 1
        fi

        echo "üìÑ SERVICE_FILE: $SERVICE_FILE"
        echo "üåç DEPLOY_ENV: {{.DEPLOY_ENV}}"

        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          # Use Docker IPFS instance via HTTP API
          if ! curl -s --connect-timeout 5 http://localhost:5001/api/v0/version > /dev/null; then
            echo "‚ùå IPFS not running on localhost:5001"
            exit 1
          fi
          
          ipfs_response=$(curl -s -X POST \
            -F "file=@${SERVICE_FILE}" \
            "http://localhost:5001/api/v0/add?only-hash=false&recursive=false&quiet=true")
          
          if [ $? -eq 0 ] && [ -n "$ipfs_response" ]; then
            ipfs_cid=$(echo "$ipfs_response" | jq -r '.Hash' 2>/dev/null || echo "$ipfs_response" | tail -1)
            if [ -n "$ipfs_cid" ] && [ "$ipfs_cid" != "null" ]; then
              echo "$ipfs_cid"
            else
              echo "‚ùå Failed to extract IPFS hash from response: $ipfs_response" >&2
              exit 1
            fi
          else
            echo "‚ùå Failed to upload to IPFS" >&2
            exit 1
          fi
        elif [ "{{.DEPLOY_ENV}}" = "TESTNET" ]; then
          if [ -z "$PINATA_API_KEY" ]; then
            echo "‚ùå PINATA_API_KEY not set" >&2
            exit 1
          fi
          ipfs_cid=$(curl -s -X POST https://api.pinata.cloud/pinning/pinFileToIPFS \
            -H "Authorization: Bearer $PINATA_API_KEY" \
            -F "file=@${SERVICE_FILE}" | jq -r '.IpfsHash')
          echo "$ipfs_cid"
        else
          echo "‚ùå Unknown DEPLOY_ENV: {{.DEPLOY_ENV}}" >&2
          exit 1
        fi

  # ===========================================
  # UTILITY TASKS
  # ===========================================

  lint:
    desc: "Run linting and formatting for all components"
    cmds:
      - |
        echo "Running cargo fmt on all Rust components..."
        find tools -name "Cargo.toml" -exec dirname {} \; | while read dir; do
          echo "Formatting: $dir"
          (cd "$dir" && cargo fmt 2>/dev/null || true)
        done
      - task: dos2unix

  test:
    desc: "Run tests for all components"
    cmds:
      - |
        echo "Running tests for all components..."
        find tools -name "Taskfile.yml" -exec dirname {} \; | while read dir; do
          component_name=$(basename "$dir")
          echo "Testing: $component_name"
          if grep -q "^  test:" "$dir/Taskfile.yml" 2>/dev/null; then
            (cd "$dir" && task test 2>/dev/null || echo "Tests failed for $component_name")
          else
            echo "No test task found for $component_name"
          fi
        done

  clean:
    desc: "Clean all build artifacts"
    cmds:
      - |
        echo "Cleaning build artifacts..."
        rm -rf {{.COMPONENTS_DIR}}/*.wasm 2>/dev/null || true
        find tools -name "Taskfile.yml" -exec dirname {} \; | while read dir; do
          component_name=$(basename "$dir")
          echo "Cleaning: $component_name"
          if grep -q "^  clean:" "$dir/Taskfile.yml" 2>/dev/null; then
            (cd "$dir" && task clean 2>/dev/null || true)
          fi
        done

  # Utility tasks

  dos2unix:
    desc: "Convert line endings to Unix format"
    cmds:
      - dos2unix ./script/* 2>/dev/null || true
      - find ./script/template -type f -exec dos2unix {} \; 2>/dev/null || true
      - find ./tools -name "script" -type d -exec find {} -type f -exec dos2unix {} \; 2>/dev/null || true

  check-prerequisites:
    desc: "Ensure all required CLI tools are installed"
    cmds:
      - |
        which cast || (echo "‚ùå 'cast' is missing. Install Foundry." && exit 1)
        which jq || (echo "‚ùå 'jq' is missing. Install it via apt/brew." && exit 1)
        which warg || (echo "‚ùå 'warg' is missing. Run: cargo binstall warg-cli" && exit 1)
        echo "‚úÖ All required tools are installed"
