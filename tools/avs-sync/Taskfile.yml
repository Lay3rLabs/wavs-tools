version: "3"

dotenv: ["../../.env"]

includes:
  cli: ../../taskfile/cli.yml
  middleware: ../../taskfile/middleware.yml
  backend: ../../taskfile/backend.yml
  config:
    taskfile: ../../taskfile/config.yml
    flatten: true

silent: true

vars:
  # These are all locally defined here, do not depend on config.yml being loaded first
  # Seems to be some sort of data race
  # For this reason, we sometimes need to redefined vars like .tool-output here 
  COMPONENT_NAME: avs_sync
  BLOCK_INTERVAL: 100
  PAST_BLOCKS: 500
  SUBMISSION_DEPLOY_SCRIPT: "Deploy.s.sol"
  SERVICE_OUTPUT_DIR: '{{joinPath .ROOT_DIR ".tool-output/services"}}'
  SERVICE_JSON_PATH: "{{.SERVICE_OUTPUT_DIR}}/{{.COMPONENT_NAME}}.json"

tasks:
  bootstrap:
    desc: "A full deployment"
    deps: [clean]
    cmds:
      - |
        task middleware-deploy
        task components-build
        task components-upload
        task contracts-deploy
        task build-service
        task upload-service
        task set-service-uri
        task register-service-uri
        task deploy-service
        task register-operator

  clean:
    desc: "Cleans up the AVS Sync tool"
    cmds:
      - rm -rf "{{.TOOL_OUTPUT_DIRNAME}}"
      - rm -rf "contracts/broadcast"
      - rm -rf "contracts/cache"
      - rm -rf "contracts/out"

  components-build:
    desc: "Builds the WASI components for AVS Sync"
    dir: "{{.REPO_ROOT}}"
    deps: [components-clean]
    cmds:
      - task component:build TOOL="avs-sync" COMPONENT_NAME="{{.COMPONENT_NAME}}" COMPONENT_SOURCE_DIR="{{.REPO_ROOT}}/tools/avs-sync/component"

  components-clean:
    desc: "Deletes the WASI components for AVS Sync"
    dir: "{{.REPO_ROOT}}"
    cmds:
      - task component:clean-all TOOL="avs-sync" COMPONENT_NAME="{{.COMPONENT_NAME}}"

  components-upload:
    desc: "Uploads the WASI components for AVS Sync"
    dir: "{{.REPO_ROOT}}"
    cmds:
      - task component:upload TOOL="avs-sync" COMPONENT_NAME="{{.COMPONENT_NAME}}"

  middleware-deploy:
    desc: "Deploys the AVS Sync middleware"
    dir: "{{.REPO_ROOT}}"
    cmds:
      - task middleware:deploy TOOL="avs-sync" SERVICE_NAME="avs-sync"

  contracts-deploy:
    desc: "Deploys the AVS Sync contracts"
    dir: contracts
    vars:
      SCRIPT_NAME: "DeployAvsWriter"
      EVM_RPC_URL:
        sh: task get-evm-rpc-url
    env:
      SERVICE_MANAGER_ADDRESS:
        sh: task get-service-manager-address 
      STAKE_REGISTRY_ADDRESS:
        sh: task get-stake-registry-address
    cmds:
      - forge script script/{{.SUBMISSION_DEPLOY_SCRIPT}}:{{.SCRIPT_NAME}} --broadcast --rpc-url "{{.EVM_RPC_URL}}"

  contracts-test:
    desc: "Runs tests for the AVS Sync contracts"
    dir: contracts
    cmds:
      - forge test -vv

  build-service:
    desc: "Build avs_sync service configuration"
    dir: "{{.REPO_ROOT}}"
    deps: [clean-service]
    vars:
      SERVICE_JSON_DOCKER_PATH: "/wavs-tools/tools/avs-sync/.tool-output/services/{{.COMPONENT_NAME}}.json"
      CMD: "service --json true --home /wavs-home --file {{.SERVICE_JSON_DOCKER_PATH}}"
      TRIGGER_CHAIN: "local"
      SUBMIT_CHAIN: "local"
      COMPONENT_DIGEST:
        sh: task get-component-digest
      SERVICE_MANAGER_ADDRESS:
        sh: task get-service-manager-address
      STAKE_REGISTRY_ADDRESS:
        sh: task get-stake-registry-address
      SUBMISSION_ADDRESS:
        sh: task get-submission-address
    cmds:
      - |
        mkdir -p {{.SERVICE_OUTPUT_DIR}}

        # Build service configuration using task cli:wavs
        SERVICE_ID=$(task cli:wavs -- {{.CMD}} init --name {{.COMPONENT_NAME}} | jq -r .service.id)

        WORKFLOW_ID=$(task cli:wavs -- {{.CMD}} workflow add | jq -r .workflow_id)

        # Configure workflow
        task cli:wavs -- {{.CMD}} workflow trigger --id ${WORKFLOW_ID} set-block-interval --chain-name {{.TRIGGER_CHAIN}} --n-blocks {{.BLOCK_INTERVAL}} > /dev/null
          
        task cli:wavs -- {{.CMD}} workflow submit --id ${WORKFLOW_ID} set-aggregator --url {{.WAVS_AGGREGATOR_ENDPOINT}} --address {{.SUBMISSION_ADDRESS}} --chain-name {{.SUBMIT_CHAIN}} > /dev/null

        task cli:wavs -- {{.CMD}} workflow component --id ${WORKFLOW_ID} set-source-digest --digest {{.COMPONENT_DIGEST}} > /dev/null
          
        task cli:wavs -- {{.CMD}} workflow component --id ${WORKFLOW_ID} permissions --http-hosts '*' --file-system true > /dev/null
          
        task cli:wavs -- {{.CMD}} workflow component --id ${WORKFLOW_ID} config --values "ecdsa_stake_registry_address={{.STAKE_REGISTRY_ADDRESS}},lookback_blocks={{.PAST_BLOCKS}}" > /dev/null
          
        task cli:wavs -- {{.CMD}} manager set-evm --chain-name {{.SUBMIT_CHAIN}} --address {{.SERVICE_MANAGER_ADDRESS}} > /dev/null

        echo "Service configuration built successfully"

  clean-service:
    desc: "Cleans up the service configuration"
    cmds:
      - rm -rf "{{.SERVICE_OUTPUT_DIR}}"

  upload-service:
    cmds:
      - |
        curl -X POST "{{.WAVS_ENDPOINT}}/save-service" -H "Content-Type: application/json" --data-binary "@{{.SERVICE_JSON_PATH}}"

  set-service-uri:
    vars:
      SERVICE_ID:
        sh: task get-service-id
      SERVICE_MANAGER_ADDRESS:
        sh: task get-service-manager-address
      EVM_RPC_URL:
        sh: task get-evm-rpc-url
      SERVICE_URI: "{{.WAVS_ENDPOINT}}/service/{{.SERVICE_ID}}"
    cmds:
      - |
        cast send {{.SERVICE_MANAGER_ADDRESS}} 'setServiceURI(string)' "{{.SERVICE_URI}}" -r {{.EVM_RPC_URL}} --private-key ${DEPLOYER_PRIVATE_KEY}

  register-service-uri:
    vars:
      SERVICE_ID:
        sh: task get-service-id
      SERVICE_URI: "{{.WAVS_ENDPOINT}}/service/{{.SERVICE_ID}}"
    cmds:
      - |
        curl -X POST "{{.WAVS_AGGREGATOR_ENDPOINT}}/register-service" -H "Content-Type: application/json" -d "{\"uri\": \"{{.SERVICE_URI}}\"}"

  deploy-service:
    vars:
      SERVICE_ID:
        sh: task get-service-id
      SERVICE_URI: "{{.WAVS_ENDPOINT}}/service/{{.SERVICE_ID}}"
    cmds:
      - 
        task cli:wavs -- deploy-service --home /wavs-home --service-url {{.SERVICE_URI}} --wavs-endpoint {{.WAVS_ENDPOINT}}

  register-operator:
    vars:
      AVS_SIGNING_ADDRESS:
        sh: task get-service-signing-address
    cmds:
      - |
        task middleware:register-operator AVS_SIGNING_ADDRESS="{{.AVS_SIGNING_ADDRESS}}" AMOUNT="0.001ether" TOOL="avs-sync" SERVICE_NAME="avs-sync"

  trigger:
    desc: "Trigger component by mining blocks"
    vars:
      BLOCKS: '{{.CLI_ARGS | default "100"}}'
      EVM_RPC_URL:
        sh: task get-evm-rpc-url
    cmds:
      - cast rpc anvil_mine {{.BLOCKS}} --rpc-url {{.EVM_RPC_URL}}

  test:
    cmds:
      - |
        # We want to check the stake registry state here then call task trigger and validate state again
        # Another test-case can be registering another operator (will need a slight refactor on the register-operator cmd)

  get-submit-events:
    vars:
      BLOCK:
        sh: cast block-number --rpc-url {{.EVM_RPC_URL}}
      BLOCK_START:
        sh: echo $(( {{.BLOCK}} - 500 ))
    cmds:
      - >
        cast logs 
        --from-block {{.BLOCK_START}}
        --to-block latest "OperatorWeightUpdated(address,uint256,uint256)"
        --address {{.STAKE_REGISTRY_ADDRESS}} 
        --rpc-url {{.EVM_RPC_URL}}

  get-component-digest:
    desc: "Get the component digest for AVS Sync"
    dir: "{{.REPO_ROOT}}"
    vars:
      COMPONENT_DIGEST_FILE:
        sh: task component:get-digest-filepath TOOL="avs-sync" COMPONENT_NAME="{{.COMPONENT_NAME}}"
      COMPONENT_DIGEST:
        sh: cat "{{.COMPONENT_DIGEST_FILE}}" 2>/dev/null || echo "Component digest file not found, please run components-upload first"
    cmds:
      - echo "{{.COMPONENT_DIGEST}}"

  get-service-id:
    desc: "Get the service ID for AVS Sync"
    vars:
      SERVICE_ID:
        sh: jq -r '.id // empty' "{{.SERVICE_JSON_PATH}}" 2>/dev/null || true
    cmds:
      - echo "{{.SERVICE_ID}}"

  get-service-manager-address:
    desc: "Get the service manager address for AVS Sync"
    dir: "{{.REPO_ROOT}}"
    vars:
      SERVICE_MANAGER_ADDRESS:
        sh: task middleware:get-service-manager-address TOOL="avs-sync" SERVICE_NAME="avs-sync"
    cmds:
      - echo "{{.SERVICE_MANAGER_ADDRESS}}"

  get-stake-registry-address:
    desc: "Get the stake registry address for AVS Sync"
    dir: "{{.REPO_ROOT}}"
    vars:
      STAKE_REGISTRY_ADDRESS:
        sh: task middleware:get-stake-registry-address TOOL="avs-sync" SERVICE_NAME="avs-sync"
    cmds:
      - echo "{{.STAKE_REGISTRY_ADDRESS}}"
  
  get-evm-rpc-url:
    desc: "Get the EVM RPC URL for AVS Sync"
    dir: "{{.REPO_ROOT}}"
    vars:
      EVM_RPC_URL:
        sh: task backend:get-evm-rpc-url-1
    cmds:
      - echo "{{.EVM_RPC_URL}}"

  get-submission-address:
    vars:
      CONTRACT_NAME: "AvsWriter"
    cmds:
      - >
        jq -r '.transactions[] | select(.contractName == "{{.CONTRACT_NAME}}") | .contractAddress // empty'
        "./contracts/broadcast/{{ .SUBMISSION_DEPLOY_SCRIPT }}/{{.MIDDLEWARE_CHAIN_ID}}/run-latest.json"

  get-service-hd-index:
    vars:
      SERVICE_ID:
        sh: task get-service-id
      SERVICE_HD_INDEX:
        sh: curl -s {{.WAVS_ENDPOINT}}/service-key/{{.SERVICE_ID}} | jq -rc '.secp256k1.hd_index'
    cmds:
      - echo "{{.SERVICE_HD_INDEX}}"

  get-service-signing-address:
    vars:
      HD_INDEX:
        sh: task get-service-hd-index
      AVS_SIGNING_ADDRESS:
        sh: cast wallet address --mnemonic-path "$WAVS_SUBMISSION_MNEMONIC" --mnemonic-index {{.HD_INDEX}}
    cmds:
      - echo "{{.AVS_SIGNING_ADDRESS}}"

  list-operators:
    desc:
      "List registered operators for AVS Sync"
    dir: "{{.REPO_ROOT}}"
    cmds:
      - task middleware:list-operators TOOL="avs-sync" SERVICE_NAME="avs-sync"

