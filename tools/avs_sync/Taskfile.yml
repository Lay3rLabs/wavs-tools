version: "3"

vars:
  ROOT: ../../
  COMPONENT_NAME: avs_sync
  COMPONENT_FILENAME: avs_sync.wasm
  PKG_NAME: avssync
  PKG_VERSION: '{{.PKG_VERSION | default "0.1.0"}}'
  BLOCK_INTERVAL: 100
  PAST_BLOCKS: 500
  PKG_NAMESPACE: "wavstools"
  TRIGGER_CHAIN: "local"
  SUBMIT_CHAIN: "local"
  STATE_DIR: ".docker"
  COMPILED_DIR: "./compiled"

tasks:
  wasi-build:
    desc: "Build WASI component"
    cmds:
      - |
        echo "Building component: {{.COMPONENT_NAME}}"

        # Create compiled directory
        mkdir -p ./compiled

        # Always build WASM component to ensure latest changes
        echo "Building WASM component..."

        # Navigate to component directory and build
        cd ./tools/{{.COMPONENT_NAME}}
        cargo component build --release
        cargo fmt

        # Find the wasm file in the workspace target directory and copy it
        TARGET_DIR="../../target/wasm32-wasip1/release"
        if [ -d "$TARGET_DIR" ]; then
          find "$TARGET_DIR" -name "*.wasm" -exec cp {} "../../compiled/" \;
          echo "‚úÖ WASM component built and copied to ../../compiled/"
        else
          echo "‚ùå Target directory not found: $TARGET_DIR"
          exit 1
        fi

  deploy:
    desc: "Complete avs_sync deployment"
    env:
      COMPONENT_NAME: "avs_sync"
      COMPONENT_FILENAME: "avs_sync.wasm"
      PKG_NAME: "avssync"
      PKG_VERSION: "0.1.0"
      AGGREGATOR_URL: "http://127.0.0.1:8001"
      WAVS_ENDPOINT: "http://127.0.0.1:8000"
    cmds:
      - |
        echo "üöÄ Deploying component: {{.COMPONENT_NAME}}"

        echo "üì¶ Building WASM component..."
        task avs_sync:wasi-build

        echo "üìÑ Deploying contracts..."
        task avs_sync:deploy-contracts

        echo "üì§ Uploading to WASI registry..."
        task avs_sync:upload-to-registry

        echo "‚öôÔ∏è Building service configuration..."
        task avs_sync:build-service

        echo "‚òÅÔ∏è Uploading service to IPFS..."
        docker cp .docker/service.json ipfs:/tmp/service.json
        ipfs_cid=$(docker exec ipfs ipfs add --pin /tmp/service.json | awk '{print $2}')
        if [ -n "$ipfs_cid" ]; then
          echo "‚úÖ Uploaded to IPFS: $ipfs_cid"
          echo "IPFS_URI=ipfs://$ipfs_cid" >> .docker/{{.COMPONENT_NAME}}.env
          export IPFS_URI="ipfs://$ipfs_cid"
        else
          echo "‚ùå Failed to upload to IPFS"
          exit 1
        fi

        echo "üìù Setting service URI on contract..."
        [ -f .docker/.state.env ] && source .docker/.state.env
        [ -f .docker/{{.COMPONENT_NAME}}.env ] && source .docker/{{.COMPONENT_NAME}}.env
        RPC_URL={{.DEPLOY_ENV | eq "LOCAL" | ternary "http://localhost:8545" "https://holesky.drpc.org"}}
        cast send ${WAVS_SERVICE_MANAGER_ADDRESS} 'setServiceURI(string)' "${IPFS_URI}" -r ${RPC_URL} --private-key ${DEPLOYER_PRIVATE_KEY}

        echo "üîÑ Starting aggregator..."
        task create-aggregator INDEX=1

        echo "üì° Starting aggregator service..."
        [ -f .docker/.state.env ] && source .docker/.state.env
        [ -f .docker/{{.COMPONENT_NAME}}.env ] && source .docker/{{.COMPONENT_NAME}}.env
        if [ -f infra/aggregator-1/start.sh ] && [ -n "$IPFS_URI" ]; then
          IPFS_GATEWAY={{.DEPLOY_ENV | eq "LOCAL" | ternary "http://127.0.0.1:8080/ipfs/" "https://gateway.pinata.cloud/ipfs/"}} bash infra/aggregator-1/start.sh
          echo "üîÑ Registering service with aggregator..."
          wget -q --header="Content-Type: application/json" --post-data="{\"uri\": \"${IPFS_URI}\"}" ${AGGREGATOR_URL}/register-service -O /dev/null
          if [ $? -eq 0 ]; then
            echo "‚úÖ Service registered with aggregator"
          else
            echo "‚ùå Failed to register service with aggregator"
            exit 1
          fi
        else
          echo "‚ùå Cannot register service - missing start.sh or IPFS_URI"
          exit 1
        fi

        echo "üîÑ Configuring WAVS operator..."
        task create-operator INDEX=1

        if ! curl -s {{.WAVS_ENDPOINT}}/app > /dev/null 2>&1; then
          echo "üöÄ Starting WAVS operator service..."
          if [ -f infra/wavs-1/start.sh ]; then
            IPFS_GATEWAY={{.DEPLOY_ENV | eq "LOCAL" | ternary "http://127.0.0.1:8080/ipfs/" "https://gateway.pinata.cloud/ipfs/"}} bash infra/wavs-1/start.sh
            sleep 5
          fi
        else
          echo "‚úÖ WAVS service already running"
        fi

        echo "üöÄ Deploying service to WAVS..."
        [ -f .docker/.state.env ] && source .docker/.state.env
        [ -f .docker/{{.COMPONENT_NAME}}.env ] && source .docker/{{.COMPONENT_NAME}}.env
        if [ -n "$IPFS_URI" ]; then
          IPFS_GATEWAY={{.DEPLOY_ENV | eq "LOCAL" | ternary "http://127.0.0.1:8080/ipfs/" "https://gateway.pinata.cloud/ipfs/"}}
          task wavs-cli INSTANCE=wavs-1 -- deploy-service --service-url ${IPFS_URI} --log-level=debug --data /data/.docker --home /data --wavs-endpoint ${WAVS_ENDPOINT} --ipfs-gateway ${IPFS_GATEWAY}
        else
          echo "‚ùå No IPFS_URI found, cannot deploy service"
          exit 1
        fi

        echo "üîë Registering operator..."
        task avs_sync:register-operator

        echo "‚úÖ Component {{.COMPONENT_NAME}} deployed successfully!"

  trigger:
    desc: "Trigger component by mining blocks"
    vars:
      BLOCKS: '{{.CLI_ARGS | default "1"}}'
      RPC_URL: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary "http://localhost:8545" "https://holesky.drpc.org"}}'
    cmds:
      - cast rpc anvil_mine {{.BLOCKS}} --rpc-url {{.RPC_URL}}

  fund-deployer:
    desc: "Fund the deployer wallet if needed"
    vars:
      RPC_URL: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary "http://localhost:8545" "https://holesky.drpc.org"}}'
      DEPLOY_ENV: '{{.DEPLOY_ENV | default "LOCAL"}}'
    cmds:
      - |
        # This task is called from root directory, no need to cd
        # Load state to get deployer address
        [ -f ./.docker/.state.env ] && source ./.docker/.state.env
        [ -f ./.docker/{{.COMPONENT_NAME}}.env ] && source ./.docker/{{.COMPONENT_NAME}}.env

        if [ -z "$DEPLOYER_ADDRESS" ]; then
          echo "‚ùå DEPLOYER_ADDRESS not found in state"
          exit 1
        fi

        echo "üîç Checking deployer funding for {{.DEPLOY_ENV}} environment..."
        echo "Using RPC URL: {{.RPC_URL}}"

        # Check if we can connect to the RPC
        if ! cast block-number --rpc-url {{.RPC_URL}} > /dev/null 2>&1; then
          if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
            echo "‚ùå Local anvil not running. Please start services first with 'task start'"
            exit 1
          else
            echo "‚ùå Cannot connect to {{.RPC_URL}}"
            exit 1
          fi
        fi

        # Check current balance
        BALANCE=$(cast balance --ether $DEPLOYER_ADDRESS --rpc-url {{.RPC_URL}})
        echo "Current deployer balance: ${BALANCE} ETH"

        # Fund if balance is less than 1 ETH and we're in LOCAL mode
        if (( $(echo "$BALANCE < 1.0" | bc -l) )); then
          if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
            echo "üí∞ Funding deployer with 15 ETH..."
            cast rpc anvil_setBalance "${DEPLOYER_ADDRESS}" '15000000000000000000' --rpc-url {{.RPC_URL}} > /dev/null
            NEW_BALANCE=$(cast balance --ether $DEPLOYER_ADDRESS --rpc-url {{.RPC_URL}})
            echo "‚úÖ Deployer funded. New balance: ${NEW_BALANCE} ETH"
          else
            echo "‚ö†Ô∏è Deployer balance is low (${BALANCE} ETH) but in TESTNET mode"
            echo "Please fund the deployer manually: ${DEPLOYER_ADDRESS}"
          fi
        else
          echo "‚úÖ Deployer already has sufficient balance"
        fi

  deploy-contracts:
    desc: "Deploy avs_sync specific contracts"
    deps: [init-component-env]
    vars:
      RPC_URL: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary "http://localhost:8545" "https://holesky.drpc.org"}}'
    cmds:
      - |
        echo "Deploying avs_sync contracts..."

        # Load environment variables from state file
        [ -f .docker/.state.env ] && source .docker/.state.env
        [ -f .docker/{{.COMPONENT_NAME}}.env ] && source .docker/{{.COMPONENT_NAME}}.env

        # Export required environment variables for forge
        export WAVS_SERVICE_MANAGER_ADDRESS
        export ECDSA_STAKE_REGISTRY_ADDRESS

        # Verify required environment variables are set
        if [ -z "$DEPLOYER_PRIVATE_KEY" ]; then
          echo "‚ùå ERROR: DEPLOYER_PRIVATE_KEY not set"
          exit 1
        fi

        if [ -z "$WAVS_SERVICE_MANAGER_ADDRESS" ]; then
          echo "‚ùå ERROR: WAVS_SERVICE_MANAGER_ADDRESS not set"
          exit 1
        fi

        if [ -z "$ECDSA_STAKE_REGISTRY_ADDRESS" ]; then
          echo "‚ùå ERROR: ECDSA_STAKE_REGISTRY_ADDRESS not set"
          exit 1
        fi

        echo "Using RPC URL: {{.RPC_URL}}"
        echo "Service Manager: $WAVS_SERVICE_MANAGER_ADDRESS"
        echo "Stake Registry: $ECDSA_STAKE_REGISTRY_ADDRESS"

        echo "Running forge script..."

        # Run forge script and capture output
        set +e
        export WAVS_SERVICE_MANAGER_ADDRESS
        export ECDSA_STAKE_REGISTRY_ADDRESS
        cd tools/avs_sync
        DEPLOY_OUTPUT=$(forge script script/DeployAvsWriter.s.sol --fork-url {{.RPC_URL}} --broadcast --private-key $DEPLOYER_PRIVATE_KEY 2>&1)
        FORGE_EXIT_CODE=$?
        cd ../..
        set -e

        echo "Forge script completed with exit code: $FORGE_EXIT_CODE"

        # Extract WAVS_SUBMIT_ADDRESS from the deployment output
        WAVS_SUBMIT_ADDRESS=$(echo "$DEPLOY_OUTPUT" | grep "AvsWriter deployed at:" | grep -o "0x[a-fA-F0-9]\{40\}")

        if [ -z "$WAVS_SUBMIT_ADDRESS" ]; then
            echo "ERROR: Could not extract WAVS_SUBMIT_ADDRESS from deployment output"
            echo "Deployment output:"
            echo "$DEPLOY_OUTPUT"
            echo "Exit code: $FORGE_EXIT_CODE"
            exit 1
        fi

        echo "AVS Writer deployed at: $WAVS_SUBMIT_ADDRESS"
        echo "WAVS_SUBMIT_ADDRESS=${WAVS_SUBMIT_ADDRESS}" >> .docker/{{.COMPONENT_NAME}}.env
        echo "AVS_SYNC_CONTRACT_ADDRESS=${WAVS_SUBMIT_ADDRESS}" >> .docker/{{.COMPONENT_NAME}}.env

  build-service:
    desc: "Build avs_sync service configuration"
    vars:
      CMD: "service --json true --home /data --file /data/.docker/service.json"
    cmds:
      - |
        # Load environment variables
        [ -f .docker/.state.env ] && source .docker/.state.env
        [ -f .docker/{{.COMPONENT_NAME}}.env ] && source .docker/{{.COMPONENT_NAME}}.env

        # Set default AGGREGATOR_URL if not provided
        if [ -z "$AGGREGATOR_URL" ]; then
          AGGREGATOR_URL="http://127.0.0.1:8001"
          echo "Using default AGGREGATOR_URL: ${AGGREGATOR_URL}"
        fi

        # Build service configuration using task wavs-cli
        SERVICE_ID=$(task wavs-cli INSTANCE=wavs-1 -- {{.CMD}} init --name {{.COMPONENT_NAME}} | jq -r .service.id)
          
        WORKFLOW_ID=$(task wavs-cli INSTANCE=wavs-1 -- {{.CMD}} workflow add | jq -r .workflow_id)

        # Configure workflow
        task wavs-cli INSTANCE=wavs-1 -- {{.CMD}} workflow trigger --id ${WORKFLOW_ID} set-block-interval --chain-name {{.TRIGGER_CHAIN}} --n-blocks {{.BLOCK_INTERVAL}} > /dev/null
          
        task wavs-cli INSTANCE=wavs-1 -- {{.CMD}} workflow submit --id ${WORKFLOW_ID} set-aggregator --url ${AGGREGATOR_URL} --address ${WAVS_SUBMIT_ADDRESS} --chain-name {{.SUBMIT_CHAIN}} > /dev/null

        # Set component from WASI registry
        # Load package info from state
        [ -f ./.docker/.state.env ] && source ./.docker/.state.env
        [ -f ./.docker/{{.COMPONENT_NAME}}.env ] && source ./.docker/{{.COMPONENT_NAME}}.env

        # Verify dynamic variables are set (static vars available as Taskfile variables)
        if [ -z "$REGISTRY" ] || [ -z "$PKG_NAMESPACE" ]; then
          echo "ERROR: Missing required dynamic variables:"
          echo "  REGISTRY: $REGISTRY"
          echo "  PKG_NAMESPACE: $PKG_NAMESPACE"
          exit 1
        fi

        echo "Using WASI package: ${PKG_NAMESPACE}:{{.PKG_NAME}}@{{.PKG_VERSION}} from ${REGISTRY}"

        task wavs-cli INSTANCE=wavs-1 -- {{.CMD}} workflow component --id ${WORKFLOW_ID} set-source-registry --domain ${REGISTRY} --package ${PKG_NAMESPACE}:{{.PKG_NAME}} --version {{.PKG_VERSION}} > /dev/null
          
        task wavs-cli INSTANCE=wavs-1 -- {{.CMD}} workflow component --id ${WORKFLOW_ID} permissions --http-hosts '*' --file-system true > /dev/null
          
        task wavs-cli INSTANCE=wavs-1 -- {{.CMD}} workflow component --id ${WORKFLOW_ID} config --values "ecdsa_stake_registry_address=${ECDSA_STAKE_REGISTRY_ADDRESS},lookback_blocks={{.PAST_BLOCKS}}" > /dev/null
          
        task wavs-cli INSTANCE=wavs-1 -- {{.CMD}} manager set-evm --chain-name {{.SUBMIT_CHAIN}} --address ${WAVS_SERVICE_MANAGER_ADDRESS} > /dev/null

        echo "Service configuration built successfully"

  init-component-env:
    desc: "Initialize component environment (run once at start)"
    cmds:
      - |
        # Ensure component state directory exists
        mkdir -p .docker

        # Always create fresh component env file for dynamic addresses
        COMPONENT_STATE_FILE=".docker/{{.COMPONENT_NAME}}.env"
        echo "# Component: {{.COMPONENT_NAME}} - Dynamic addresses only" > "$COMPONENT_STATE_FILE"

  upload-to-registry:
    desc: "Upload component to WASI registry"
    vars:
      DEPLOY_ENV: '{{.DEPLOY_ENV | default "LOCAL"}}'
      REGISTRY: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary "localhost:8090" "wa.dev"}}'
      PKG_NAMESPACE_VAR: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary .PKG_NAMESPACE ""}}'
    cmds:
      - |
        REGISTRY="{{.REGISTRY}}"

        # Get PKG_NAMESPACE based on DEPLOY_ENV
        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          PKG_NAMESPACE="{{.PKG_NAMESPACE_VAR}}"
        else
          read -p "Enter the PKG_NAMESPACE for ${REGISTRY}: " namespace
          PKG_NAMESPACE="${namespace}"
        fi

        COMPONENT_PATH="compiled/{{.COMPONENT_FILENAME}}"
        if [ ! -f "$COMPONENT_PATH" ]; then
          echo "‚ùå Component file not found: $COMPONENT_PATH"
          exit 1
        fi

        # Determine protocol
        PROTOCOL="https"
        if [[ "$REGISTRY" == *"localhost"* ]] || [[ "$REGISTRY" == *"127.0.0.1"* ]]; then
            PROTOCOL="http"
        fi

        PACKAGE_NAME="${PKG_NAMESPACE}:{{.PKG_NAME}}"
        echo "üì§ Uploading: $COMPONENT_PATH"
        echo "   To: ${PROTOCOL}://${REGISTRY}/${PACKAGE_NAME}@{{.PKG_VERSION}}"

        # Upload with proper error handling
        set +e
        output=$(warg publish release --registry ${PROTOCOL}://${REGISTRY} --name ${PKG_NAMESPACE}:{{.PKG_NAME}} --version {{.PKG_VERSION}} ${COMPONENT_PATH} 2>&1)
        exit_code=$?

        if [[ $exit_code -ne 0 ]]; then
            if [[ "$output" =~ "failed to prove inclusion" ]]; then
                echo "‚úÖ Package uploaded to local registry successfully..."
                echo "   (This is expected for local registries)"
            elif [[ "$output" =~ "already released" ]]; then
                echo "‚úÖ Package already exists in registry - using existing version"
            elif [[ "$output" =~ "error sending request for url" ]]; then
                echo "‚ö†Ô∏è Registry not available - check that you are running the registry locally"
                echo "${output}"
            elif [[ "$output" =~ "namespace.*is not defined" ]]; then
                echo "‚úÖ Package uploaded to local registry (namespace auto-created)"
                echo "   (This is expected for local registries)"
            else
                echo "‚ö†Ô∏è Upload error: ${output}"
            fi
        else
            echo "‚úÖ Package uploaded successfully"
        fi
        set -e

        # Store dynamic registry info in component env file
        {
          echo "REGISTRY=${REGISTRY}"
          echo "PKG_NAMESPACE=${PKG_NAMESPACE}"
        } >> ".docker/{{.COMPONENT_NAME}}.env"

  upload-service-to-ipfs:
    desc: "Upload service configuration to IPFS"
    vars:
      DEPLOY_ENV: '{{.DEPLOY_ENV | default "LOCAL"}}'
    env:
      PINATA_API_KEY: '{{.PINATA_API_KEY | default ""}}'
    cmds:
      - |
        SERVICE_FILE=".docker/service.json"
        if [ -z "$SERVICE_FILE" ] || [ ! -f "$SERVICE_FILE" ]; then
          echo "‚ùå SERVICE_FILE not set or does not exist: '$SERVICE_FILE'"
          exit 1
        fi

        echo "üìÑ SERVICE_FILE: $SERVICE_FILE"
        echo "üåç DEPLOY_ENV: {{.DEPLOY_ENV}}"

        # Use docker exec approach for IPFS upload since HTTP API has issues
        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          docker cp ${SERVICE_FILE} ipfs:/tmp/service.json
          ipfs_cid=$(docker exec ipfs ipfs add --pin /tmp/service.json | awk '{print $2}')
        else
          ipfs_cid=$(DEPLOY_ENV="{{.DEPLOY_ENV}}" SERVICE_FILE="$SERVICE_FILE" task upload-to-ipfs | tail -1)
        fi

        if [ -n "$ipfs_cid" ]; then
          echo "‚úÖ Uploaded to IPFS: $ipfs_cid"
          echo "IPFS_URI=ipfs://$ipfs_cid" >> "./.docker/{{.COMPONENT_NAME}}.env"
        else
          echo "‚ùå Failed to upload to IPFS"
          echo "IPFS_URI=" >> "./.docker/{{.COMPONENT_NAME}}.env"
        fi

  register-operator:
    desc: "Register operator with AVS"
    cmds:
      - |
        # Load state
        [ -f .docker/.state.env ] && source .docker/.state.env
        [ -f .docker/{{.COMPONENT_NAME}}.env ] && source .docker/{{.COMPONENT_NAME}}.env

        # Get AVS signing key info
        SERVICE_INDEX=0
        DEFAULT_ENV_FILE="infra/wavs-1/.env"

        SERVICE_ID=$(jq -r '.id' .docker/service.json)

        HD_INDEX=$(curl -s http://localhost:8000/service-key/${SERVICE_ID} | jq -rc '.secp256k1.hd_index')

        source ${DEFAULT_ENV_FILE}
        OPERATOR_PRIVATE_KEY=$(cast wallet private-key --mnemonic "$WAVS_SUBMISSION_MNEMONIC" --mnemonic-index 0)
        AVS_SIGNING_ADDRESS=$(cast wallet address --mnemonic-path "$WAVS_SUBMISSION_MNEMONIC" --mnemonic-index ${HD_INDEX})

        echo "Registering operator with AVS..."
        echo "Service Manager: $WAVS_SERVICE_MANAGER_ADDRESS"
        echo "HD Index: ${HD_INDEX}"
        echo "Service ID: ${SERVICE_ID}"
        echo "AVS Signing Address: ${AVS_SIGNING_ADDRESS}"

        task wavs-middleware WAVS_SERVICE_MANAGER_ADDRESS=${WAVS_SERVICE_MANAGER_ADDRESS} -- register ${OPERATOR_PRIVATE_KEY} ${AVS_SIGNING_ADDRESS} 0.001ether
