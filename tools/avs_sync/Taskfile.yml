version: "3"

vars:
  ROOT: ../../
  COMPONENT_NAME: avs_sync
  COMPONENT_FILENAME: avs_sync.wasm
  PKG_NAME: avssync
  PKG_VERSION: '{{.PKG_VERSION | default "0.1.0"}}'
  BLOCK_INTERVAL: 100
  PAST_BLOCKS: 500
  PKG_NAMESPACE: "wavstools"
  TRIGGER_CHAIN: "local"
  SUBMIT_CHAIN: "local"
  STATE_DIR: ".docker"
  COMPILED_DIR: "./compiled"

tasks:
  # ===========================================
  # PUBLIC TASKS (Component-specific commands)
  # ===========================================

  wasi-build:
    desc: "Build WASI component"
    cmds:
      - |
        echo "Building component: {{.COMPONENT_NAME}}"

        # Create compiled directory
        mkdir -p ./compiled

        # Always build WASM component to ensure latest changes
        echo "Building WASM component..."

        # Navigate to component directory and build
        cd ./tools/{{.COMPONENT_NAME}}
        cargo component build --release
        cargo fmt

        # Find the wasm file in the workspace target directory and copy it
        TARGET_DIR="../../target/wasm32-wasip1/release"
        if [ -d "$TARGET_DIR" ]; then
          find "$TARGET_DIR" -name "*.wasm" -exec cp {} "../../compiled/" \;
          echo "‚úÖ WASM component built and copied to ../../compiled/"
        else
          echo "‚ùå Target directory not found: $TARGET_DIR"
          exit 1
        fi

  deploy:
    desc: "Complete avs_sync deployment - does everything automatically"
    cmds:
      - |
        echo "üöÄ Starting complete avs_sync deployment..."

        # Step 1: Build WASM
        echo "üì¶ Step 1: Building WASM component..."
        task avs_sync:wasi-build

        # Step 2: Ensure environment and middleware
        echo "üîß Step 2: Setting up environment and middleware..."
        task avs_sync:ensure-middleware

        # Step 3: Deploy contracts
        echo "üìÑ Step 3: Deploying contracts..."
        task avs_sync:deploy-contracts

        # Step 4: Upload to WASI registry
        echo "üì§ Step 4: Uploading to WASI registry..."
        task avs_sync:upload-to-registry

        # Step 5: Build service configuration
        echo "‚öôÔ∏è Step 5: Building service configuration..."
        task avs_sync:build-service

        # Step 6: Upload service to IPFS
        echo "‚òÅÔ∏è Step 6: Uploading service to IPFS..."
        task avs_sync:upload-service-to-ipfs

        # Step 7: Start aggregator and operator services
        echo "üîÑ Step 7: Starting aggregator and operator services..."
        task start-aggregator-and-operator

        # Step 8: Register service with aggregator
        echo "üì° Step 8: Registering service with aggregator..."
        [ -f ../../.docker/.state.env ] && source ../../.docker/.state.env
        if [ -n "$IPFS_URI" ]; then
          task register-service-with-aggregator IPFS_URI="$IPFS_URI"
        fi

        # Step 9: Deploy service to WAVS
        echo "üöÄ Step 9: Deploying service to WAVS..."
        if [ -n "$IPFS_URI" ]; then
          task deploy-service-to-wavs SERVICE_URL="$IPFS_URI"
        fi

        # Step 10: Register operator
        echo "üîë Step 10: Registering operator..."
        task register-operator

        # Step 11: Set service URI on contract
        echo "üìù Step 11: Setting service URI on contract..."
        if [ -n "$IPFS_URI" ]; then
          task set-service-uri IPFS_URI="$IPFS_URI"
        fi

        echo "‚úÖ Complete avs_sync deployment finished!"
        echo "üéâ Your component is deployed and running!"

  trigger:
    desc: "Trigger component by mining blocks"
    vars:
      BLOCKS: '{{.CLI_ARGS | default "1"}}'
      RPC_URL: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary "http://localhost:8545" "https://holesky.drpc.org"}}'
    cmds:
      - cast rpc anvil_mine {{.BLOCKS}} --rpc-url {{.RPC_URL}}

  list-operators:
    desc: "List operators (usage: task list-operators BLOCKS=<n>)"
    vars:
      BLOCKS: '{{.BLOCKS | default "500"}}'
    env:
      PAST_BLOCKS: "{{.BLOCKS}}"
    cmds:
      - task wavs-middleware CLI_ARGS="list_operator"

  ensure-middleware:
    desc: "Ensure WAVS middleware is deployed and deployer is funded"
    cmds:
      - |
        # This task is called from root directory, no need to cd
        echo "üîß Initializing environment..."
        task init-environment

        echo "üí∞ Checking deployer funding..."
        task avs_sync:fund-deployer

        # Check if middleware is already deployed by looking for state
        if [ ! -f ./.docker/.state.env ] || ! grep -q "WAVS_SERVICE_MANAGER_ADDRESS" ./.docker/.state.env; then
          echo "üöÄ Deploying WAVS middleware first..."
          task deploy-middleware
        else
          echo "‚úÖ WAVS middleware already deployed"
        fi

  fund-deployer:
    desc: "Fund the deployer wallet if needed"
    vars:
      RPC_URL: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary "http://localhost:8545" "https://holesky.drpc.org"}}'
      DEPLOY_ENV: '{{.DEPLOY_ENV | default "LOCAL"}}'
    cmds:
      - |
        # This task is called from root directory, no need to cd
        # Load state to get deployer address
        [ -f ./.docker/.state.env ] && source ./.docker/.state.env

        if [ -z "$DEPLOYER_ADDRESS" ]; then
          echo "‚ùå DEPLOYER_ADDRESS not found in state"
          exit 1
        fi

        echo "üîç Checking deployer funding for {{.DEPLOY_ENV}} environment..."
        echo "Using RPC URL: {{.RPC_URL}}"

        # Check if we can connect to the RPC
        if ! cast block-number --rpc-url {{.RPC_URL}} > /dev/null 2>&1; then
          if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
            echo "‚ùå Local anvil not running. Please start services first with 'task start'"
            exit 1
          else
            echo "‚ùå Cannot connect to {{.RPC_URL}}"
            exit 1
          fi
        fi

        # Check current balance
        BALANCE=$(cast balance --ether $DEPLOYER_ADDRESS --rpc-url {{.RPC_URL}})
        echo "Current deployer balance: ${BALANCE} ETH"

        # Fund if balance is less than 1 ETH and we're in LOCAL mode
        if (( $(echo "$BALANCE < 1.0" | bc -l) )); then
          if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
            echo "üí∞ Funding deployer with 15 ETH..."
            cast rpc anvil_setBalance "${DEPLOYER_ADDRESS}" '15000000000000000000' --rpc-url {{.RPC_URL}} > /dev/null
            NEW_BALANCE=$(cast balance --ether $DEPLOYER_ADDRESS --rpc-url {{.RPC_URL}})
            echo "‚úÖ Deployer funded. New balance: ${NEW_BALANCE} ETH"
          else
            echo "‚ö†Ô∏è Deployer balance is low (${BALANCE} ETH) but in TESTNET mode"
            echo "Please fund the deployer manually: ${DEPLOYER_ADDRESS}"
          fi
        else
          echo "‚úÖ Deployer already has sufficient balance"
        fi

  # ===========================================
  # DEPLOYMENT TASKS
  # ===========================================

  deploy-contracts:
    desc: "Deploy avs_sync specific contracts"
    deps: [setup-component-env]
    vars:
      RPC_URL: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary "http://localhost:8545" "https://holesky.drpc.org"}}'
    cmds:
      - |
        echo "Deploying avs_sync contracts..."

        # Load environment variables from state file
        [ -f .docker/.state.env ] && source .docker/.state.env

        # Export required environment variables for forge
        export WAVS_SERVICE_MANAGER_ADDRESS
        export ECDSA_STAKE_REGISTRY_ADDRESS

        # Verify required environment variables are set
        if [ -z "$DEPLOYER_PRIVATE_KEY" ]; then
          echo "‚ùå ERROR: DEPLOYER_PRIVATE_KEY not set"
          exit 1
        fi

        if [ -z "$WAVS_SERVICE_MANAGER_ADDRESS" ]; then
          echo "‚ùå ERROR: WAVS_SERVICE_MANAGER_ADDRESS not set"
          exit 1
        fi

        if [ -z "$ECDSA_STAKE_REGISTRY_ADDRESS" ]; then
          echo "‚ùå ERROR: ECDSA_STAKE_REGISTRY_ADDRESS not set"
          exit 1
        fi

        echo "Using RPC URL: {{.RPC_URL}}"
        echo "Service Manager: $WAVS_SERVICE_MANAGER_ADDRESS"
        echo "Stake Registry: $ECDSA_STAKE_REGISTRY_ADDRESS"

        echo "Running forge script..."

        # Run forge script and capture output
        set +e
        export WAVS_SERVICE_MANAGER_ADDRESS
        export ECDSA_STAKE_REGISTRY_ADDRESS
        cd tools/avs_sync
        DEPLOY_OUTPUT=$(forge script script/DeployAvsWriter.s.sol --fork-url {{.RPC_URL}} --broadcast --private-key $DEPLOYER_PRIVATE_KEY 2>&1)
        FORGE_EXIT_CODE=$?
        cd ../..
        set -e

        echo "Forge script completed with exit code: $FORGE_EXIT_CODE"

        # Extract WAVS_SUBMIT_ADDRESS from the deployment output
        WAVS_SUBMIT_ADDRESS=$(echo "$DEPLOY_OUTPUT" | grep "AvsWriter deployed at:" | grep -o "0x[a-fA-F0-9]\{40\}")

        if [ -z "$WAVS_SUBMIT_ADDRESS" ]; then
            echo "ERROR: Could not extract WAVS_SUBMIT_ADDRESS from deployment output"
            echo "Deployment output:"
            echo "$DEPLOY_OUTPUT"
            echo "Exit code: $FORGE_EXIT_CODE"
            exit 1
        fi

        echo "AVS Writer deployed at: $WAVS_SUBMIT_ADDRESS"
        echo "WAVS_SUBMIT_ADDRESS=${WAVS_SUBMIT_ADDRESS}" >> .docker/.state.env
        echo "AVS_SYNC_CONTRACT_ADDRESS=${WAVS_SUBMIT_ADDRESS}" >> .docker/.state.env

  build-service:
    desc: "Build avs_sync service configuration"
    deps: [setup-component-env]
    vars:
      CMD: "service --json true --home /data --file /data/.docker/service.json"
    cmds:
      - |
        # Load environment variables
        [ -f .docker/.state.env ] && source .docker/.state.env

        # Set default AGGREGATOR_URL if not provided
        if [ -z "$AGGREGATOR_URL" ]; then
          AGGREGATOR_URL="http://127.0.0.1:8001"
          echo "Using default AGGREGATOR_URL: ${AGGREGATOR_URL}"
        fi

        # Build service configuration directly with docker
        WAVS_DOCKER_IMAGE="ghcr.io/lay3rlabs/wavs:{{.WAVS_DOCKER_TAG | default "35c96a4"}}"
        
        SERVICE_ID=$(docker run --rm --network host \
          -w /data -v $(pwd):/data $WAVS_DOCKER_IMAGE \
          wavs-cli {{.CMD}} init --name {{.COMPONENT_NAME}} | jq -r .service.id)
          
        WORKFLOW_ID=$(docker run --rm --network host \
          -w /data -v $(pwd):/data $WAVS_DOCKER_IMAGE \
          wavs-cli {{.CMD}} workflow add | jq -r .workflow_id)

        # Configure workflow
        docker run --rm --network host \
          -w /data -v $(pwd):/data $WAVS_DOCKER_IMAGE \
          wavs-cli {{.CMD}} workflow trigger --id ${WORKFLOW_ID} set-block-interval --chain-name {{.TRIGGER_CHAIN}} --n-blocks {{.BLOCK_INTERVAL}} > /dev/null
          
        docker run --rm --network host \
          -w /data -v $(pwd):/data $WAVS_DOCKER_IMAGE \
          wavs-cli {{.CMD}} workflow submit --id ${WORKFLOW_ID} set-aggregator --url ${AGGREGATOR_URL} --address ${WAVS_SUBMIT_ADDRESS} --chain-name {{.SUBMIT_CHAIN}} > /dev/null

        # Set component from WASI registry
        # Load package info from state
        [ -f ./.docker/.state.env ] && source ./.docker/.state.env

        # Verify all required variables are set
        if [ -z "$REGISTRY" ] || [ -z "$PKG_NAMESPACE" ] || [ -z "$PKG_NAME" ] || [ -z "$PKG_VERSION" ]; then
          echo "ERROR: Missing required variables:"
          echo "  REGISTRY: $REGISTRY"
          echo "  PKG_NAMESPACE: $PKG_NAMESPACE"
          echo "  PKG_NAME: $PKG_NAME"
          exit 1
        fi

        echo "Using WASI package: ${PKG_NAMESPACE}:${PKG_NAME}@${PKG_VERSION} from ${REGISTRY}"
        
        docker run --rm --network host \
          -w /data -v $(pwd):/data $WAVS_DOCKER_IMAGE \
          wavs-cli {{.CMD}} workflow component --id ${WORKFLOW_ID} set-source-registry --domain ${REGISTRY} --package ${PKG_NAMESPACE}:${PKG_NAME} --version ${PKG_VERSION} > /dev/null
          
        docker run --rm --network host \
          -w /data -v $(pwd):/data $WAVS_DOCKER_IMAGE \
          wavs-cli {{.CMD}} workflow component --id ${WORKFLOW_ID} permissions --http-hosts '*' --file-system true > /dev/null
          
        docker run --rm --network host \
          -w /data -v $(pwd):/data $WAVS_DOCKER_IMAGE \
          wavs-cli {{.CMD}} workflow component --id ${WORKFLOW_ID} config --values "ecdsa_stake_registry_address=${ECDSA_STAKE_REGISTRY_ADDRESS},lookback_blocks={{.PAST_BLOCKS}}" > /dev/null
          
        docker run --rm --network host \
          -w /data -v $(pwd):/data $WAVS_DOCKER_IMAGE \
          wavs-cli {{.CMD}} manager set-evm --chain-name {{.SUBMIT_CHAIN}} --address ${WAVS_SERVICE_MANAGER_ADDRESS} > /dev/null

        echo "Service configuration built successfully"

  setup-component-env:
    desc: "Setup component environment"
    cmds:
      - |
        # Ensure component state directory exists
        mkdir -p .docker

        # Always create fresh component-specific state file
        COMPONENT_STATE_FILE=".docker/{{.COMPONENT_NAME}}.env"
        cat > "$COMPONENT_STATE_FILE" << EOF
        # Component: {{.COMPONENT_NAME}}
        COMPONENT_NAME={{.COMPONENT_NAME}}
        COMPONENT_FILENAME={{.COMPONENT_FILENAME}}
        PKG_NAME={{.PKG_NAME}}
        PKG_VERSION={{.PKG_VERSION}}
        PKG_NAMESPACE={{.PKG_NAMESPACE}}
        BLOCK_INTERVAL={{.BLOCK_INTERVAL}}
        PAST_BLOCKS={{.PAST_BLOCKS}}
        TRIGGER_CHAIN={{.TRIGGER_CHAIN}}
        SUBMIT_CHAIN={{.SUBMIT_CHAIN}}
        EOF

  upload-to-registry:
    desc: "Upload component to WASI registry"
    deps: [setup-component-env]
    vars:
      DEPLOY_ENV: '{{.DEPLOY_ENV | default "LOCAL"}}'
      REGISTRY: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary "localhost:8090" "wa.dev"}}'
      PKG_NAMESPACE_VAR: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary .PKG_NAMESPACE ""}}'
    cmds:
      - |
        REGISTRY="{{.REGISTRY}}"

        # Get PKG_NAMESPACE based on DEPLOY_ENV
        if [ "{{.DEPLOY_ENV}}" = "LOCAL" ]; then
          PKG_NAMESPACE="{{.PKG_NAMESPACE_VAR}}"
        else
          read -p "Enter the PKG_NAMESPACE for ${REGISTRY}: " namespace
          PKG_NAMESPACE="${namespace}"
        fi

        COMPONENT_PATH="compiled/{{.COMPONENT_FILENAME}}"
        if [ ! -f "$COMPONENT_PATH" ]; then
          echo "‚ùå Component file not found: $COMPONENT_PATH"
          exit 1
        fi

        # Determine protocol
        PROTOCOL="https"
        if [[ "$REGISTRY" == *"localhost"* ]] || [[ "$REGISTRY" == *"127.0.0.1"* ]]; then
            PROTOCOL="http"
        fi

        PACKAGE_NAME="${PKG_NAMESPACE}:{{.PKG_NAME}}"
        echo "üì§ Uploading: $COMPONENT_PATH"
        echo "   To: ${PROTOCOL}://${REGISTRY}/${PACKAGE_NAME}@{{.PKG_VERSION}}"

        # Upload with proper error handling
        set +e
        output=$(warg publish release --registry ${PROTOCOL}://${REGISTRY} --name ${PKG_NAMESPACE}:{{.PKG_NAME}} --version {{.PKG_VERSION}} ${COMPONENT_PATH} 2>&1)
        exit_code=$?
        warg reset --registry ${PROTOCOL}://${REGISTRY}

        if [[ $exit_code -ne 0 ]]; then
            if [[ "$output" =~ "failed to prove inclusion" ]]; then
                echo "‚úÖ Package uploaded to local registry successfully..."
                echo "   (This is expected for local registries)"
            elif [[ "$output" =~ "already released" ]]; then
                echo "‚úÖ Package already exists in registry - using existing version"
            elif [[ "$output" =~ "error sending request for url" ]]; then
                echo "‚ö†Ô∏è Registry not available - check that you are running the registry locally"
                echo "${output}"
            elif [[ "$output" =~ "namespace.*is not defined" ]]; then
                echo "‚úÖ Package uploaded to local registry (namespace auto-created)"
                echo "   (This is expected for local registries)"
            else
                echo "‚ö†Ô∏è Upload error: ${output}"
            fi
        else
            echo "‚úÖ Package uploaded successfully"
        fi
        set -e

        # Store registry info in state for service configuration
        {
          echo "REGISTRY=${REGISTRY}"
          echo "PKG_NAMESPACE=${PKG_NAMESPACE}"
          echo "PKG_NAME={{.PKG_NAME}}"
          echo "PKG_VERSION={{.PKG_VERSION}}"
        } >> ".docker/.state.env"

  upload-service-to-ipfs:
    desc: "Upload service configuration to IPFS"
    vars:
      DEPLOY_ENV: '{{.DEPLOY_ENV | default "LOCAL"}}'
    env:
      PINATA_API_KEY: '{{.PINATA_API_KEY | default ""}}'
    cmds:
      - |
        SERVICE_FILE=".docker/service.json"
        if [ -z "$SERVICE_FILE" ] || [ ! -f "$SERVICE_FILE" ]; then
          echo "‚ùå SERVICE_FILE not set or does not exist: '$SERVICE_FILE'"
          exit 1
        fi

        echo "üìÑ SERVICE_FILE: $SERVICE_FILE"
        echo "üåç DEPLOY_ENV: {{.DEPLOY_ENV}}"

        ipfs_cid=$(DEPLOY_ENV="{{.DEPLOY_ENV}}" SERVICE_FILE="$SERVICE_FILE" task upload-to-ipfs | tail -1)

        if [ -n "$ipfs_cid" ]; then
          echo "‚úÖ Uploaded to IPFS: $ipfs_cid"
          echo "IPFS_URI=ipfs://$ipfs_cid" >> "./.docker/.state.env"
        else
          echo "‚ùå Failed to upload to IPFS"
          echo "IPFS_URI=" >> "./.docker/.state.env"
        fi

  register-service-with-aggregator:
    desc: "Register service with aggregator"
    vars:
      AGGREGATOR_URL: '{{.AGGREGATOR_URL | default "http://127.0.0.1:8001"}}'
      IPFS_URI: "{{.IPFS_URI}}"
    cmds:
      - |
        if [ -z "{{.IPFS_URI}}" ]; then
          echo "‚ùå IPFS_URI is required"
          exit 1
        fi

        echo "üì° Registering service with aggregator at {{.AGGREGATOR_URL}}..."
        response=$(wget -q --header="Content-Type: application/json" \
          --post-data='{"uri": "{{.IPFS_URI}}"}' \
          {{.AGGREGATOR_URL}}/register-service -O -)

        if [ $? -eq 0 ]; then
          echo "‚úÖ Service registered with aggregator"
          echo "Response: $response"
        else
          echo "‚ùå Failed to register service with aggregator"
          exit 1
        fi

  deploy-service-to-wavs:
    desc: "Deploy service to WAVS instance"
    vars:
      WAVS_ENDPOINT: '{{.WAVS_ENDPOINT | default "http://127.0.0.1:8000"}}'
      SERVICE_URL: "{{.SERVICE_URL}}"
      IPFS_GATEWAY: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary "http://127.0.0.1:8080/ipfs/" "https://gateway.pinata.cloud/ipfs/"}}'
    cmds:
      - |
        if [ -z "{{.SERVICE_URL}}" ]; then
          echo "‚ùå SERVICE_URL is required"
          exit 1
        fi

        # Check WAVS service availability
        echo "üîç Checking WAVS service at {{.WAVS_ENDPOINT}}..."
        TIMEOUT=60
        ELAPSED=0

        while [ $ELAPSED -lt $TIMEOUT ]; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" {{.WAVS_ENDPOINT}}/app)
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ WAVS service is running"
            break
          fi
          
          echo "‚è≥ Waiting for WAVS service... (${ELAPSED}s/${TIMEOUT}s)"
          sleep 2
          ELAPSED=$((ELAPSED + 2))
        done

        if [ $ELAPSED -ge $TIMEOUT ]; then
          echo "‚ùå WAVS service not reachable at {{.WAVS_ENDPOINT}} after ${TIMEOUT}s"
          exit 1
        fi

        echo "üöÄ Deploying service from: {{.SERVICE_URL}}..."
        cd         task wavs-cli CLI_ARGS="deploy-service --service-url {{.SERVICE_URL}} --log-level=debug --data /data/.docker --home /data --wavs-endpoint {{.WAVS_ENDPOINT}} --ipfs-gateway {{.IPFS_GATEWAY}}"

  register-operator:
    desc: "Register operator with AVS"
    cmds:
      - |
        # Load state
        [ -f .docker/.state.env ] && source .docker/.state.env

        # Get AVS signing key info
        SERVICE_INDEX=0
        DEFAULT_ENV_FILE="infra/wavs-1/.env"

        SERVICE_ID=$(curl -s http://localhost:8000/app | jq -r ".services[${SERVICE_INDEX}].id")
        if [ -z "$SERVICE_ID" ] || [ "$SERVICE_ID" == "null" ]; then
          echo "‚ùå Error: SERVICE_ID is null or not found for index ${SERVICE_INDEX}."
          exit 1
        fi

        HD_INDEX=$(curl -s http://localhost:8000/service-key/${SERVICE_ID} | jq -rc '.secp256k1.hd_index')

        source ${DEFAULT_ENV_FILE}
        OPERATOR_PRIVATE_KEY=$(cast wallet private-key --mnemonic "$WAVS_SUBMISSION_MNEMONIC" --mnemonic-index 0)
        AVS_SIGNING_ADDRESS=$(cast wallet address --mnemonic-path "$WAVS_SUBMISSION_MNEMONIC" --mnemonic-index ${HD_INDEX})

        echo "Registering operator with AVS..."
        echo "Service Manager: $WAVS_SERVICE_MANAGER_ADDRESS"
        echo "HD Index: ${HD_INDEX}"
        echo "Service ID: ${SERVICE_ID}"
        echo "AVS Signing Address: ${AVS_SIGNING_ADDRESS}"

        cd         task wavs-middleware CLI_ARGS="register ${OPERATOR_PRIVATE_KEY} ${AVS_SIGNING_ADDRESS} 0.001ether"

  set-service-uri:
    desc: "Set service URI on WAVS Service Manager contract"
    vars:
      IPFS_URI: "{{.IPFS_URI}}"
      RPC_URL: '{{.DEPLOY_ENV | default "LOCAL" | eq "LOCAL" | ternary "http://localhost:8545" "https://holesky.drpc.org"}}'
    cmds:
      - |
        # Load state
        [ -f .docker/.state.env ] && source .docker/.state.env

        if [ -n "$DEPLOYER_PRIVATE_KEY" ] && [ -n "{{.IPFS_URI}}" ] && [ -n "$WAVS_SERVICE_MANAGER_ADDRESS" ]; then
          echo "üìù Setting service URI on WAVS Service Manager..."
          cast send $WAVS_SERVICE_MANAGER_ADDRESS 'setServiceURI(string)' "{{.IPFS_URI}}" \
            -r {{.RPC_URL}} --private-key $DEPLOYER_PRIVATE_KEY
          echo "‚úÖ Service URI set successfully"
        else
          echo "‚ö†Ô∏è Skipping service URI setting - required variables not available"
          echo "  DEPLOYER_PRIVATE_KEY: ${DEPLOYER_PRIVATE_KEY:+set}"
          echo "  IPFS_URI: {{.IPFS_URI}}"
          echo "  WAVS_SERVICE_MANAGER_ADDRESS: ${WAVS_SERVICE_MANAGER_ADDRESS:+set}"
        fi

  # ===========================================
  # UTILITY TASKS
  # ===========================================

  clean:
    desc: "Clean build artifacts"
    cmds:
      - cargo clean
      - rm -f compiled/{{.COMPONENT_FILENAME}} 2>/dev/null || true

  test:
    desc: "Run component tests"
    cmds:
      - cargo test

  fmt:
    desc: "Format code"
    cmds:
      - cargo fmt
